<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM</title>
    <url>/2022/11/22/JVM/</url>
    <content><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><blockquote>
<p>栈、堆、本地方法栈、程序计数器、方法区（元空间）</p>
</blockquote>
<ul>
<li>程序计数器：</li>
</ul>
<p>​		用于保存当前线程的行号，它是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。</p>
<ul>
<li>本地方法栈：</li>
</ul>
<p>​		用于对JVM所需要的方法提供支持，用于管理本地方法的调用，里面并没有我们写的代码逻辑，<strong>其由native修饰，由 C 语言实现。</strong></p>
<ul>
<li>JVM栈：</li>
</ul>
<p>​		用于保存栈帧。 每当方法被调用时，都会产生一个栈帧用于保存局部变量表、操作数栈等；用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<strong>（栈里面存的是地址，实际指向的是堆里面的对象）</strong></p>
<ul>
<li>方法区（Java8叫元空间）：</li>
</ul>
<p>​		用于<strong>保存已经被JVM加载了的类的信息、常量及静态变量等数据。</strong>运行时常量池也在方法区。</p>
<ul>
<li>堆（Heap）：</li>
</ul>
<p>​		<strong>用于保存所有对象的实例以及数组（但不是所有的对象实例都在堆中）；</strong>物理内存上并不连续。Java 虚拟机中内存最大的一块，<strong>是被所有线程共享的</strong>，几乎所有的对象实例都在这里分配内存。</p>
<p>​		其大小通过**-Xms(最小值)<strong>和</strong>-Xmx(最大值)**参数设置（最大最小值都要小于1G），前者为启动时申请的最小内存，默认为操作系统物理内存的1&#x2F;64，后者为JVM可申请的最大内存,默认为物理内存的1&#x2F;4，默认当空余堆内存小于40%时，JVM会增大堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation&#x3D;来指定这个比列。</p>
<p><strong>线程私有：</strong>栈、本地方法栈、程序计数器。每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存。</p>
<p><strong>全局共享：</strong>堆区、方法区</p>
<p>&#x3D;&#x3D;栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的。&#x3D;&#x3D;</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS登录</title>
    <url>/2022/08/06/CAS%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h3 id="1、CAS介绍"><a href="#1、CAS介绍" class="headerlink" title="1、CAS介绍"></a>1、CAS介绍</h3><p><a href="https://so.csdn.net/so/search?q=cas&amp;t=blog&amp;u=Anumbrella&amp;s=new">https://so.csdn.net/so/search?q=cas&amp;t=blog&amp;u=Anumbrella&amp;s=new</a></p>
<p>CAS最基本的协议过程：</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220807153953551.png" class="">

<p>CAS Client与受保护的客户端应用部署在一起，以Filter方式保护受保护的资源。对于访问受保护资源的每个Web请求，CAS Client会分析该请求的Http请求中是否包含Service Ticket，如果没有，则说明当前用户尚未登录，于是将请求重定向到指定好的CAS Server登录地址，并传递Service（也就是要访问的目的资源地址），以便登录成功过后转回该地址。用户在第3步中输入认证信息，如果登录成功，CAS Server随机产生一个相当长度、唯一、不可伪造的Service Ticket，并缓存以待将来验证，之后系统自动重定向到Service所在地址，并为客户端浏览器设置一个Ticket Granted Cookie（TGC），CAS Client在拿到Service和新产生的Ticket过后，在第5，6步中与CAS Server进行身份核实，以确保Service Ticket的合法性。</p>
<p>在该协议中，所有与CAS的交互均采用SSL协议，确保ST和TGC的安全性。协议工作过程中会有2次重定向的过程，但是CAS Client与CAS Server之间进行Ticket验证的过程对于用户是透明的。</p>
<p>另外，CAS协议中还提供了Proxy（代理）模式，以适应更加高级、复杂的应用场景，具体参考CAS官方文档。</p>
<h4 id="1-1、Ticket"><a href="#1-1、Ticket" class="headerlink" title="1.1、Ticket"></a>1.1、Ticket</h4><blockquote>
<h3 id="TGT：Ticket-Grangting-Ticket"><a href="#TGT：Ticket-Grangting-Ticket" class="headerlink" title="TGT：Ticket Grangting Ticket"></a>TGT：Ticket Grangting Ticket</h3></blockquote>
<p> 为用户签发的登录票据，其中封装了Cookie的值（Cookie值中包含用户信息），用户CAS认证通过后，CAS Server生成TGT存储在缓存中，并生成TGC（Ticket Grangting Cookie）理解为sessionId，写入浏览器。HTTP请求到达时，会验证是否包含TGC，包含则以此为key在缓存中查找TGT，如果有说明用户登录过并且未过期，如果没有需要重新登录。</p>
<blockquote>
<h3 id="TGC：Ticket-Grangting-Cookie"><a href="#TGC：Ticket-Grangting-Cookie" class="headerlink" title="TGC：Ticket Grangting Cookie"></a>TGC：Ticket Grangting Cookie</h3></blockquote>
<p>上面提到的TGT存入缓存中，而TGC即为缓存标识，通过TGC寻找到TGT。</p>
<blockquote>
<h3 id="ST：Service-Ticket"><a href="#ST：Service-Ticket" class="headerlink" title="ST：Service Ticket"></a>ST：Service Ticket</h3></blockquote>
<p> 用户访问某一Service的票据。当用户调用CAS Client某一Service时，会验证用户是否含有ST，如果没有，则要求用户到CAS Server获取ST，如果用户请求中包含TGC，则CAS会以此查找缓存中的TGT，如果存在TGT，则用此TGT签发ST，返回给用户。用户凭借ST再次访问该Service，Service携带ST到CAS Server进行验证，验证通过后允许用户访问资源。</p>
<p> 为了保证安全，ST是随机生成的，另外，CAS规定，CAS只能存活一定的时间，并且规定ST只能使用一次，无论ST是否验证成功，CAS Server都会清除服务端缓存中的该Ticket，保证同一个ST不能被使用两次。</p>
<h4 id="1-2、认证过程"><a href="#1-2、认证过程" class="headerlink" title="1.2、认证过程"></a>1.2、认证过程</h4><ul>
<li>第一步：</li>
</ul>
<p> 1、用户请求客户端，客户端验证本地Session没有该用户信息。</p>
<p> 2、客户端检测到此次请求中没有ST。</p>
<p> 3、客户端返回给用户Redirect响应，到CAS Server，携带service参数，例如：</p>
<p> 302 Location : <a href="https://cas.example.com/cas/login?service=http0:8081/">https://cas.example.com/cas/login?service=http0%3A8081%2F</a></p>
<ul>
<li>第二步：</li>
</ul>
<p> 1、CAS Server检测到该次请求中不包含TGC，跳转到登录页。</p>
<p> 2、用户输入用户名密码进行登录认证，成功后CAS Server生成TGT（集成用户信息及ST），并随机生成TGC，将TGC写入Cookie。</p>
<p> 3、CAS Server返回给用户Redirect响应，到service中的地址，携带ST参数及包含TGC的Cookie，例如：</p>
<p> Set-Cookie : CASTGC&#x3D;TGT-2345678</p>
<p> 302 Location : <a href="http://baidu.com/web1?ticket=ST-5-Sx6eyvj7cPPCfn0pMZ">http://baidu.com/web1?ticket=ST-5-Sx6eyvj7cPPCfn0pMZ</a></p>
<ul>
<li>第三步：</li>
</ul>
<p> 1、用户携带ticket(ST)再次请求CAS Client，客户端Authentication Filter检测到请求中带有ticket参数，会跳过，由Ticket Validation Filter处理。</p>
<p> 2、Ticket Validation Filter 携带ticket(ST)及service访问CAS Server的&#x2F;serviceValidate接口，希望CAS Server验证ST有效性。</p>
<p> 3、CAS Server验证成功，将用户信息通过xml方式返回给Ticket Validation Filter，当该Filter接收到验证成功的响应时，把用户信息存入缓存。至此，SSO会话成功建立。</p>
<ul>
<li>第四步：</li>
</ul>
<p> 1、Client将用户信息存入缓存，并生成SessionId写入cookie，返回给用户Redirect响应，到用户请求的服务地址。例如：</p>
<p> Set-Cookie : JSESSIONID&#x3D;ABC123456</p>
<p> 302 Location : <a href="http://baidu.com/web1">http://baidu.com/web1</a></p>
<p> 2、用户接下来的访问只需要验证SessionId即可，无需再向CAS Server请求验证。</p>
<p>当用户访问同一个CAS Server但是不同的CAS Client时：</p>
<p> 1、同样CAS Client2检测缓存中没有该次请求的用户信息，没有ST，Client2返回给用户Redirect响应，携带service参数，到CAS Server。</p>
<p> 2、这是用户第二次访问CAS Server，此时Request的Cookie中会携带第一次签发的TGC，CAS Server根据TGC查找缓存中是否有对应的TGT，例如：</p>
<p> Set-Cookie : CASTGC&#x3D;TGT-2345678</p>
<p> 302 Location : <a href="https://cas.example.com/cas/login?service=http://app.com/web">https://cas.example.com/cas/login?service=http://app.com/web</a></p>
<p> 3、如果有，说明用户登录过且未过期，用户不必再次登陆，CAS Server会直接找到TGT签发ST，返回给客户端Redirect响应，到service中的地址，例如：</p>
<p> Set-Cookie : CASTGC&#x3D;TGT-2345678</p>
<p> 302 Location : <a href="http://app.com/web?ticket=ST-8-SoIdlj7cPPCfn0pMZ">http://app.com/web?ticket=ST-8-SoIdlj7cPPCfn0pMZ</a></p>
<p> 4、用户携带ticket(ST)再次请求CAS Client，客户端Authentication Filter检测到请求中带有ticket参数，会跳过，由Ticket Validation Filter处理。</p>
<p> 5、Ticket Validation Filter 携带ticket(ST)及service访问CAS Server的&#x2F;serviceValidate接口，希望CAS Server验证ST有效性。</p>
<p> 6、CAS Server验证成功，将用户信息通过xml方式返回给Ticket Validation Filter，当该Filter接收到验证成功的响应时，把用户信息存入缓存。至此，SSO会话成功建立。</p>
<p> 7、Client将用户信息存入缓存，并生成SessionId写入cookie，返回给用户Redirect响应，到用户请求的服务地址。例如：</p>
<p> Set-Cookie : JSESSIONID&#x3D;ABC123456</p>
<p> 302 Location : <a href="http://app.com/web">http://app.com/web</a></p>
<p> 8、用户接下来的访问只需要验证SessionId即可，无需再向CAS Server请求验证。</p>
<h3 id="2、搭建Tomcat-Https支持"><a href="#2、搭建Tomcat-Https支持" class="headerlink" title="2、搭建Tomcat Https支持"></a>2、搭建Tomcat Https支持</h3><hr>
<h4 id="2-1、生成密钥库"><a href="#2-1、生成密钥库" class="headerlink" title="2.1、生成密钥库"></a>2.1、生成密钥库</h4><p>使用JDK自带的keytools工具生成密钥库</p>
<p>别名：caskey 存储路径：D:\Work\Projects\cas\keystore\caskey.keystore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -genkey -v -alias caskey -keyalg RSA -keystore D:\Work\Projects\cas\keystore\caskey.keystore</span><br></pre></td></tr></table></figure>

<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806212042310.png" class="">

<h4 id="2-2、从密钥库导出证书"><a href="#2-2、从密钥库导出证书" class="headerlink" title="2.2、从密钥库导出证书"></a>2.2、从密钥库导出证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -export -trustcacerts -alias caskey -file  D:\Work\Projects\cas\keystore\caskey.cer -keystore D:\Work\Projects\cas\keystore\caskey.keystore</span><br></pre></td></tr></table></figure>

<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806212653642.png" class="">

<h4 id="2-3、将证书导入到JDK证书库"><a href="#2-3、将证书导入到JDK证书库" class="headerlink" title="2.3、将证书导入到JDK证书库"></a>2.3、将证书导入到JDK证书库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -import -trustcacerts -alias caskey -file D:\Work\Projects\cas\keystore\caskey.cer -keystore D:\Work\Servers\Java\jdk1.8.0_181\jre\lib\security\cacerts</span><br></pre></td></tr></table></figure>

<p>密码：changeit</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806213157447.png" class="">

<h4 id="2-4、证书其他命令"><a href="#2-4、证书其他命令" class="headerlink" title="2.4、证书其他命令"></a>2.4、证书其他命令</h4><p><a href="https://blog.csdn.net/gmaaa123/article/details/107460922">https://blog.csdn.net/gmaaa123/article/details/107460922</a></p>
<h4 id="2-5、Tomcat配置https支持及乱码修改"><a href="#2-5、Tomcat配置https支持及乱码修改" class="headerlink" title="2.5、Tomcat配置https支持及乱码修改"></a>2.5、Tomcat配置https支持及乱码修改</h4><p>这里采用tomcat9，找到tomcat\conf\server.xml打开文件，加入如下配置即可：</p>
<p>keystoreFile为证书地址，keystorePass为证书密钥</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">SSLEnabled</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scheme</span>=<span class="string">&quot;https&quot;</span> <span class="attr">secure</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           	   <span class="attr">clientAuth</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sslProtocol</span>=<span class="string">&quot;TLS&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">keystoreFile</span>=<span class="string">&quot;D:\Work\Projects\cas\keystore\caskey.keystore&quot;</span></span></span><br><span class="line"><span class="tag">           	   <span class="attr">keystorePass</span>=<span class="string">&quot;wzc1996&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动bin下的startup.bat</p>
<p>Tomcat默认有中文乱码，在conf子目录中，找到<code>&quot;logging.properties&quot;</code>文件，打开文件，找到如下配置项：</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806214732109.png" class="">

<p>将UTF-8修改为GBK，保存重启！</p>
<h4 id="2-6、测试"><a href="#2-6、测试" class="headerlink" title="2.6、测试"></a>2.6、测试</h4><p>通过<code>https://localhost:8443</code>端口可以访问</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806214949877.png" class="">



<h3 id="3、CAS-Server服务端搭建"><a href="#3、CAS-Server服务端搭建" class="headerlink" title="3、CAS Server服务端搭建"></a>3、CAS Server服务端搭建</h3><hr>
<h4 id="3-1、CAS-Server-war-下载"><a href="#3-1、CAS-Server-war-下载" class="headerlink" title="3.1、CAS Server war 下载"></a>3.1、CAS Server war 下载</h4><p>官网：<a href="https://www.apereo.org/">https://www.apereo.org/</a></p>
<p>GitHub官网：<a href="https://github.com/apereo/cas">https://github.com/apereo/cas</a></p>
<p>CAS服务端：<a href="https://github.com/apereo/cas-overlay-template">https://github.com/apereo/cas-overlay-template</a></p>
<p>maven仓库：<a href="https://repo1.maven.org/maven2/cas/">https://repo1.maven.org/maven2/cas/</a></p>
<p>war包地址：<a href="https://repo1.maven.org/maven2/org/apereo/cas/cas-server-webapp-tomcat/5.3.14">https://repo1.maven.org/maven2/org/apereo/cas/cas-server-webapp-tomcat/5.3.14</a></p>
<p>下载</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806220423381.png" class="">

<h4 id="3-2、CAS-Server发布到Tomcat"><a href="#3-2、CAS-Server发布到Tomcat" class="headerlink" title="3.2、CAS Server发布到Tomcat"></a>3.2、CAS Server发布到Tomcat</h4><p>将下载的war包放到Tomcat的webapp目录下，将包名改为cas，访问：<a href="https://localhost:8443/cas">https://localhost:8443/cas</a></p>
<p>配置日志路径：打开<code>WEB-INF\classes\log4j2.xml</code>文件，修改成实际日志路径</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220807000649129.png" class="">

<p>配置hosts：修改C:\Windows\System32\hosts，可以使用域名访问</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220806223755547.png" class="">

<p>默认用户名和密码，位于<code>application.properties</code>文件中</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220807001001155.png" class="">

<h4 id="3-3、配置数据源，数据库用户认证"><a href="#3-3、配置数据源，数据库用户认证" class="headerlink" title="3.3、配置数据源，数据库用户认证"></a>3.3、配置数据源，数据库用户认证</h4><p>1：建表</p>
<p>2：修改application.properties配置文件，注释掉写死的认证用户，加上jdbc数据源配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cas.authn.accept.users=casuser::Mellon</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?serverTimezone=GMT</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].password</span>=<span class="string">wzc1996</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].sql</span>=<span class="string">select * from user where username = ?</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].fieldPassword</span>=<span class="string">password</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>3：加上jdbc驱动包以及支持jar</p>
<p><code>cas-server-support-jdbc-5.3.14.jar</code></p>
<p><code>cas-server-support-jdbc-authentication-5.3.14.jar</code></p>
<p><code>cas-server-support-jdbc-drivers-5.3.14.jar</code></p>
<p><code>mysql-connection-java-5.1.28-bin.jar</code></p>
<h4 id="3-4、密码加密校验"><a href="#3-4、密码加密校验" class="headerlink" title="3.4、密码加密校验"></a>3.4、密码加密校验</h4><p>1：数据库生成下MD5密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> md5(<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>2：修改application.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cas.authn.jdbc.query[0].passwordEncoder.type</span>=<span class="string">DEFAULT</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].passwordEncoder.characterEncoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># MD5加密策略</span></span><br><span class="line"><span class="attr">cas.authn.jdbc.query[0].passwordEncoder.encodingAlgorithm</span>=<span class="string">MD5</span></span><br></pre></td></tr></table></figure>

<p>3：测试OK</p>
<h4 id="3-5-其他配置"><a href="#3-5-其他配置" class="headerlink" title="3.5 其他配置"></a>3.5 其他配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在退出时是否需要 确认一下  true确认 false直接退出，这里是CAS服务端的确认，实际情况用不到</span></span><br><span class="line"><span class="attr">cas.logout.confirmLogout</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#在CAS客户端退出时的配置</span></span><br><span class="line"><span class="comment"># 默认情况下退出登录时，页面将会跳转到CAS服务器内部的注销页面 casLogoutView.jsp ，</span></span><br><span class="line"><span class="comment"># 如果我们需要在退出登录后，跳转到指定页面,需要将下列参数设为true,在退出登录的url里需要添加service参数，该参数指定在注销后需要跳转的页面,配置允许登出后跳转到指定页面,</span></span><br><span class="line"><span class="attr">cas.logout.followServiceRedirects</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#跳转到指定页面需要的参数名为 service(default)</span></span><br><span class="line"><span class="attr">cas.logout.redirectParameter</span>=<span class="string">service</span></span><br><span class="line"><span class="comment">#是否移除子系统的票据</span></span><br><span class="line"><span class="attr">cas.logout.removeDescendantTickets</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5、CAS-Redis"><a href="#3-5、CAS-Redis" class="headerlink" title="3.5、CAS Redis"></a>3.5、CAS Redis</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cas 的redis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apereo.cas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-server-support-redis-ticket-registry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cas.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其次配置application.properties</span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.host</span>=<span class="string">127.0.0.1  </span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.database</span>=<span class="string">0  </span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.port</span>=<span class="string">6379  </span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.password</span>=<span class="string">p123456</span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.timeout</span>=<span class="string">2000 </span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.useSsl</span>=<span class="string">false </span></span><br><span class="line"><span class="attr">cas.ticket.registry.redis.usePool</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h3 id="4、CAS-Client-SpringBoot客户端整合搭建"><a href="#4、CAS-Client-SpringBoot客户端整合搭建" class="headerlink" title="4、CAS Client+SpringBoot客户端整合搭建"></a>4、CAS Client+SpringBoot客户端整合搭建</h3><hr>
<p>项目搭建，加入cas client依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cas.version</span>&gt;</span>2.3.0-GA<span class="tag">&lt;/<span class="name">cas.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.unicon.cas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-autoconfig-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cas.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加application.yml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cas:</span><br><span class="line">  server-url-prefix: https://localhost:8443/cas  # cas服务端地址</span><br><span class="line">  server-login-url: https://localhost:8443/cas/login #cas登录页</span><br><span class="line">  client-host-url: http://localhost:8080  #登录成功跳转地址</span><br><span class="line">  validation-type: cas3</span><br></pre></td></tr></table></figure>

<p>启动类添加<code>@EnableCasClient</code>注解</p>
<p>运行报错：</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220807152433436.png" class="">

<p>报错原因是cas服务器默认不支持http请求，可以通过配置来让其支持http请求：</p>
<p>1、在<code>\WEB-INF\classes\services</code>目录下，修改<code>HTTPSandIMAPS-10000001.json</code>文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;serviceId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;^(https|imaps)://.*&quot;</span><span class="punctuation">,</span></span><br><span class="line">改为</span><br><span class="line"><span class="attr">&quot;serviceId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;^(https|http|imaps)://.*&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>2、在<code>\WEB-INF\classes</code>下，修改<code>application.properties</code>文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略https安全协议，使用 HTTP 协议</span></span><br><span class="line"><span class="attr">cas.tgc.secure</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 是否开启json识别功能,默认为false</span></span><br><span class="line"><span class="attr">cas.serviceRegistry.initFromJson</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h3 id="5、显示用户名"><a href="#5、显示用户名" class="headerlink" title="5、显示用户名"></a>5、显示用户名</h3><hr>
<p>CAS客户端经过CAS Server认证后，CAS客户端可以去CAS Server端拿到登录认证的信息，比如用户名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码中通过一下方法获取用户名</span></span><br><span class="line"><span class="type">Assertion</span> <span class="variable">assertion</span> <span class="operator">=</span> AssertionHolder.getAssertion();</span><br><span class="line"><span class="type">AttributePrincipal</span> <span class="variable">principal</span> <span class="operator">=</span> assertion.getPrincipal();</span><br><span class="line"><span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> principal.getName();</span><br></pre></td></tr></table></figure>

<p>thymeleaf页面可以<code>$&#123;session._const_cas_assertion_.principal.name&#125;</code>取值；</p>
<p>可以通过如下源码找到</p>
<img src="/2022/08/06/CAS%E7%99%BB%E5%BD%95/image-20220809095537660.png" class="">

<h3 id="6、注销"><a href="#6、注销" class="headerlink" title="6、注销"></a>6、注销</h3><p>href接口重定向到<code>https://localhost:8443/cas/logout</code></p>
<h3 id="7、CAS单点登录实例实现-测试"><a href="#7、CAS单点登录实例实现-测试" class="headerlink" title="7、CAS单点登录实例实现+测试"></a>7、CAS单点登录实例实现+测试</h3><h3 id="8、CAS-Server界面修改"><a href="#8、CAS-Server界面修改" class="headerlink" title="8、CAS Server界面修改"></a>8、CAS Server界面修改</h3><p>cas server用到springmvc + webflow实现；</p>
]]></content>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2022/09/29/Java/</url>
    <content><![CDATA[<h5 id="Java序列化为什么要实现Serializable接口并指定serialVersionUID值"><a href="#Java序列化为什么要实现Serializable接口并指定serialVersionUID值" class="headerlink" title="Java序列化为什么要实现Serializable接口并指定serialVersionUID值"></a>Java序列化为什么要实现Serializable接口并指定serialVersionUID值</h5><ul>
<li><p>没有实现序列化会报错：&#x3D;&#x3D;NotSerializableException&#x3D;&#x3D;</p>
</li>
<li><p>没有指定serialVersionUID值：&#x3D;&#x3D;InvalidClassException&#x3D;&#x3D;，序列化和反序列化是的serialVersionUID不同</p>
</li>
</ul>
<p>结论：实现Serializable接口不指定uid的话，会自动分配一个随机的uid，如果在序列化后修改了这个类，那么uid就会改变，再反序列化的化，会找不到原来uid对应的类，因为原来的类发送改变了。</p>
<hr>
<h5 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h5><blockquote>
<p>default修饰方法只能在接口中使用，在接口中被default标记的方法为普通方法，可以直接写方法体。</p>
</blockquote>
<ul>
<li><p>实现类会继承接口中的default方法</p>
</li>
<li><p>如果一个类同时实现接口A和B，接口A和B中有相同的default方法，这时，该类必须重写接口中的default方法</p>
<ul>
<li>为什么要重写呢？是因为，类在继承接口中的default方法时，不知道应该继承哪一个接口中的default方法</li>
</ul>
</li>
<li><p>如果子类继承父类，父类中有b方法，该子类同时实现的接口中也有b方法（被default修饰），那么子类会继承父类的b方法而不是继承接口中的b方法</p>
</li>
</ul>
<hr>
<h5 id="浅拷贝-amp-深拷贝"><a href="#浅拷贝-amp-深拷贝" class="headerlink" title="浅拷贝&amp;深拷贝"></a>浅拷贝&amp;深拷贝</h5><p><strong>浅拷贝：</strong></p>
<blockquote>
<p>引用拷贝&amp;对象拷贝</p>
</blockquote>
<ul>
<li>引用拷贝：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher2</span> <span class="operator">=</span> teacher1;</span><br><span class="line">    System.out.println(teacher1);</span><br><span class="line">    System.out.println(teacher2);</span><br><span class="line">&#125;</span><br><span class="line">com.wzzc.frame.utils.Teacher<span class="meta">@cc34f4d</span></span><br><span class="line">com.wzzc.frame.utils.Teacher<span class="meta">@cc34f4d</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;栈区的student1和student2指向的是堆区的同一个引用对象&#x3D;&#x3D;</p>
<ul>
<li>对象拷贝：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">     <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">     <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;12&quot;</span>,teacher);</span><br><span class="line">     <span class="comment">//进行拷贝</span></span><br><span class="line">     <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone(); </span><br><span class="line">     <span class="comment">//修改属性值</span></span><br><span class="line">     teacher.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">     System.out.println(student1.getTeacher().getName());</span><br><span class="line">     System.out.println(student2.getTeacher().getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">李四</span><br><span class="line">李四</span><br></pre></td></tr></table></figure>

<p>对于对象而言，赋值的只是这个对象的引用，将原对象的引用传递过去，实际上还是指向同一个对象。</p>
<p><strong>深拷贝：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="comment">//        浅复制</span></span><br><span class="line"><span class="comment">//        return super.clone();</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line"><span class="comment">//        本来是浅复制，现在将Teacher对象复制一份并重新set进来</span></span><br><span class="line">        student.setTeacher((Teacher) student.getTeacher().clone());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">李四</span><br><span class="line">张三</span><br></pre></td></tr></table></figure>

<p>重写克隆方法的时候，重新拷贝了一个对象，此时student1和student2引用调用的teacher引用所指向的已经是各自的teacher对象。所有，当修改student1调用的teacher引用所对应的对象时，对student2对应的teacher对象一点影响也没有！</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础</title>
    <url>/2022/10/12/MySql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="MylSAM和InnoDB"><a href="#MylSAM和InnoDB" class="headerlink" title="MylSAM和InnoDB"></a>MylSAM和InnoDB</h1><table>
<thead>
<tr>
<th></th>
<th>MylSAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据行锁定</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>外键约束</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表空间大小</td>
<td>较小</td>
<td>较大，约为2倍</td>
</tr>
</tbody></table>
<p>常规使用操作：</p>
<ul>
<li>MylSAM	节约空间，速度较快</li>
<li>InnoDB     安全性高，事务处理，多表操作</li>
</ul>
<h1 id="MySql函数"><a href="#MySql函数" class="headerlink" title="MySql函数"></a>MySql函数</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="数据函数"><a href="#数据函数" class="headerlink" title="数据函数"></a>数据函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-8</span>); <span class="comment">/*绝对值*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">9.4</span>); <span class="comment">/*向上取整*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">9.4</span>); <span class="comment">/*向下取整*/</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND(); <span class="comment">/*随机数,返回一个0-1之间的随机数*/</span></span><br><span class="line"><span class="keyword">SELECT</span> SIGN(<span class="number">0</span>); <span class="comment">/*符号函数: 负数返回-1,正数返回1,0返回0*/</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;狂神说坚持就能成功&#x27;</span>); <span class="comment">/*返回字符串包含的字符数*/</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;爱&#x27;</span>,<span class="string">&#x27;程序&#x27;</span>); <span class="comment">/*合并字符串,参数可以有多个*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSERT</span>(<span class="string">&#x27;我爱编程helloworld&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;超级热爱&#x27;</span>); <span class="comment">/*替换字符串,从某个位置开始替</span></span><br><span class="line"><span class="comment">换某个长度*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;KuangShen&#x27;</span>); <span class="comment">/*小写*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;KuangShen&#x27;</span>); <span class="comment">/*大写*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;hello,world&#x27;</span>,<span class="number">5</span>); <span class="comment">/*从左边截取*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">&#x27;hello,world&#x27;</span>,<span class="number">5</span>); <span class="comment">/*从右边截取*/</span></span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;狂神说坚持就能成功&#x27;</span>,<span class="string">&#x27;坚持&#x27;</span>,<span class="string">&#x27;努力&#x27;</span>); <span class="comment">/*替换字符串*/</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;狂神说坚持就能成功&#x27;</span>,<span class="number">4</span>,<span class="number">6</span>); <span class="comment">/*截取字符串,开始和长度*/</span></span><br><span class="line"><span class="keyword">SELECT</span> REVERSE(<span class="string">&#x27;狂神说坚持就能成功&#x27;</span>); <span class="comment">/*反转</span></span><br><span class="line"><span class="comment">-- 查询姓周的同学,改成邹</span></span><br><span class="line"><span class="comment">SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) AS 新名字</span></span><br><span class="line"><span class="comment">FROM student WHERE studentname LIKE &#x27;周%&#x27;;</span></span><br></pre></td></tr></table></figure>

<h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>(); <span class="comment">/*获取当前日期*/</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE(); <span class="comment">/*获取当前日期*/</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW(); <span class="comment">/*获取当前日期和时间*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>(); <span class="comment">/*获取当前日期和时间*/</span></span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE(); <span class="comment">/*获取当前日期和时间*/</span></span><br><span class="line"><span class="comment">-- 获取年月日,时分秒</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(NOW());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION(); <span class="comment">/*版本*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(); <span class="comment">/*用户*/</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT()</td>
<td>返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回数字字段或表达式列作统计，返回一列的总和。</td>
</tr>
<tr>
<td>AVG()</td>
<td>通常为数值字段或表达列作统计，返回一列的平均值。</td>
</tr>
<tr>
<td>MAX()</td>
<td>可以为数值字段，字符字段或表达式列作统计，返回最大的值。</td>
</tr>
<tr>
<td>MIN(）</td>
<td>可以为数值字段，字符字段或表达式列作统计，返回最小的值。</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="comment">/*COUNT:非空的*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(studentname) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> student; <span class="comment">/*推荐*/</span></span><br><span class="line"><span class="comment">-- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。</span></span><br><span class="line"><span class="comment">-- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null</span></span><br><span class="line">的记录。</span><br><span class="line"><span class="comment">-- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录；</span></span><br><span class="line"><span class="comment">-- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)</span></span><br><span class="line"><span class="comment">可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的</span></span><br><span class="line"><span class="comment">条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不</span></span><br><span class="line"><span class="comment">同，它会统计该字段不为null的记录条数。</span></span><br><span class="line"><span class="comment">下面它们之间的一些对比：</span></span><br><span class="line"><span class="comment">1）在表没有主键时，count(1)比count(*)快</span></span><br><span class="line"><span class="comment">2）有主键时，主键作为计算条件，count(主键)效率最高；</span></span><br><span class="line"><span class="comment">3）若表格只有一个字段，则count(*)效率较高。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(StudentResult) <span class="keyword">AS</span> 总和 <span class="keyword">FROM</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(StudentResult) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(StudentResult) <span class="keyword">AS</span> 最高分 <span class="keyword">FROM</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(StudentResult) <span class="keyword">AS</span> 最低分 <span class="keyword">FROM</span> <span class="keyword">result</span>;</span><br></pre></td></tr></table></figure>



<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>什么是事务</p>
</blockquote>
<ul>
<li>事务就是将一组SQL语句放在同一批次内去执行</li>
<li>如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行</li>
<li>MySQL事务处理只支持InnoDB和BDB数据表类型</li>
</ul>
<blockquote>
<p>事务的ACID原则</p>
</blockquote>
<p><strong>原子性(Atomic)</strong></p>
<p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执 行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过 一样。</p>
<p><strong>一致性(Consist)</strong></p>
<p>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不 管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务 一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五 个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多 个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之 间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。</p>
<p><strong>隔离性(Isolated)</strong></p>
<p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相 同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系 统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同 一时间仅有一个请求用于同一数据。</p>
<p><strong>持久性(Durable)</strong></p>
<p>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p><strong>基本语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用set语句来改变自动提交模式</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; <span class="comment">/*关闭*/</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>; <span class="comment">/*开启*/</span></span><br><span class="line"><span class="comment">-- 注意:</span></span><br><span class="line"><span class="comment">--- 1.MySQL中默认是自动提交</span></span><br><span class="line"><span class="comment">--- 2.使用事务时应先关闭自动提交</span></span><br><span class="line"><span class="comment">-- 开始一个事务,标记事务的起始点</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"><span class="comment">-- 提交一个事务给数据库</span></span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="comment">-- 将事务回滚,数据回到本次事务的初始状态</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"><span class="comment">-- 还原MySQL数据库的自动提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 回滚到保存点</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 删除保存点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote>
<p>MySql官方对索引的定义为：索引（index）是帮助MySql高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引就是数据结构</p>
</blockquote>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><ul>
<li>主键索引 (Primary Key)：某一个属性组能唯一标识一条记录<ul>
<li>最常见的索引类型</li>
<li>确保数据记录的唯一性</li>
<li>确定特定数据记录在数据库中的位置</li>
</ul>
</li>
<li>唯一索引 (Unique)：避免同一个表中某数据列中的值重复<ul>
<li>主键索引只能有一个</li>
<li>唯一索引可能有多个</li>
</ul>
</li>
<li>常规索引 (Index)：快速定位特定数据<ul>
<li>index 和 key 关键字都可以设置常规索引</li>
<li>应加在查询找条件的字段</li>
<li>不宜添加太多常规索引,影响数据的插入,删除和修改操作</li>
</ul>
</li>
<li>全文索引 (FullText)：快速定位特定数据<ul>
<li>只能用于MyISAM类型的数据表</li>
<li>只能用于CHAR , VARCHAR , TEXT数据列类型</li>
<li>适合大型数据集</li>
</ul>
</li>
</ul>
<h2 id="测试索引"><a href="#测试索引" class="headerlink" title="测试索引"></a>测试索引</h2><h3 id="建表app-user"><a href="#建表app-user" class="headerlink" title="建表app_user"></a>建表app_user</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `app_user` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">`email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户邮箱&#x27;</span>,</span><br><span class="line">`phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">`gender` tinyint(<span class="number">4</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别（0:男；1：女）&#x27;</span>,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">`age` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">`update_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;app用户表&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> mock_data;</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mock_data()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> num <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> num DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> app_user(`name`, `email`, `phone`, `gender`, `password`,</span><br><span class="line">`age`)</span><br><span class="line"><span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;用户&#x27;</span>, i), <span class="string">&#x27;24736743@qq.com&#x27;</span>, CONCAT(<span class="string">&#x27;18&#x27;</span>, <span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span></span><br><span class="line">(<span class="number">999999999</span><span class="number">-100000000</span>)<span class="operator">+</span><span class="number">100000000</span>)),<span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span><span class="number">2</span>),UUID(),</span><br><span class="line"><span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span><span class="number">100</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">SELECT</span> mock_data();</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ELECT <span class="operator">*</span> <span class="keyword">FROM</span> app_user <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;用户9999&#x27;</span>; <span class="comment">-- 查看耗时</span></span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_app_user_name <span class="keyword">ON</span> app_user(name);</span><br></pre></td></tr></table></figure>

<h2 id="索引准则"><a href="#索引准则" class="headerlink" title="索引准则"></a>索引准则</h2><ul>
<li>索引不是越多越好</li>
<li>不要对经常变动的数据加索引</li>
<li>小数据量的表建议不要加索引</li>
<li>索引一般应加在查找条件的字段</li>
</ul>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><ul>
<li>hash类型的索引：查询单条快，范围查询慢</li>
<li>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</li>
</ul>
<p>关于索引的本质：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">导出一张表 -- mysqldump -uroot -p123456 school student &gt;D:/a.sql</span><br><span class="line">mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line">导出多张表 -- mysqldump -uroot -p123456 school student result &gt;D:/a.sql</span><br><span class="line">mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</span><br><span class="line">导出所有表 -- mysqldump -uroot -p123456 school &gt;D:/a.sql</span><br><span class="line">mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">导出一个库 -- mysqldump -uroot -p123456 -B school &gt;D:/a.sql</span><br><span class="line">mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql)</span><br></pre></td></tr></table></figure>



<h1 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h1><ul>
<li>第一范式：<ul>
<li>原子性：保证每一列不可再分</li>
<li>指数据库表的每一列都是不可分割的基本数据项。</li>
</ul>
</li>
<li>第二范式：<ul>
<li>必须满足第一范式</li>
<li>非主属性完全依赖于主关键字，不能依赖于主键的一部分</li>
<li>要求每个表只描述一件事情</li>
</ul>
</li>
<li>第三范式<ul>
<li>满足第一范式和第二范式</li>
<li>任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li>
<li>确保数据表中的每一列数据都和主键直接相关，而不能间接相关</li>
</ul>
</li>
</ul>
<p><strong>规范化和性能的关系</strong></p>
<p>&#x3D;&#x3D;关联查询的表不得超过三张&#x3D;&#x3D;</p>
<ul>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间（从多表查询变为单表查询）</li>
<li>通过在给定的表中插入计算列,以方便查询</li>
</ul>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为JDBC。 这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就 可以操作数据库。</p>
<p><img src="/MySql%E5%9F%BA%E7%A1%80%5Cimage-20221014171257329.png"></p>
<h2 id="编写JDBC程序"><a href="#编写JDBC程序" class="headerlink" title="编写JDBC程序"></a>编写JDBC程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcFirstDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//要连接的数据库URL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/jdbcStudy?</span></span><br><span class="line"><span class="string">        useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用</span></span><br><span class="line">        这种方式来加载驱动</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//推荐使用这种方式来加载驱动</span></span><br><span class="line">        <span class="comment">//2.获取与数据库的链接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3.获取用于向数据库发送sql语句的statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,password,email,birthday from users&quot;</span>;</span><br><span class="line">        <span class="comment">//4.向数据库发sql,并获取代表结果集的resultset</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);</span><br><span class="line">        <span class="comment">//5.取出结果集的数据</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;id=&quot;</span> + rs.getObject(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;name=&quot;</span> + rs.getObject(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;password=&quot;</span> + rs.getObject(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;email=&quot;</span> + rs.getObject(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;birthday=&quot;</span> + rs.getObject(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.关闭链接，释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        st.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象说明"><a href="#对象说明" class="headerlink" title="对象说明"></a>对象说明</h2><blockquote>
<p>DriverManager类讲解</p>
</blockquote>
<p>Jdbc程序中的DriverManager用于加载驱动，并创建与数据库的链接，这个API的常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver())</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"><span class="comment">//connection代表数据库</span></span><br><span class="line"><span class="comment">//数据库设置自动提交</span></span><br><span class="line"><span class="comment">//事务提交</span></span><br><span class="line"><span class="comment">//事务回滚  </span></span><br><span class="line">connection.rollback();</span><br><span class="line">connection.commit();</span><br><span class="line">connection.setAutoCommit();</span><br></pre></td></tr></table></figure>

<p>注意：在实际开发中并不推荐采用registerDriver方法注册驱动。原因有二：</p>
<ul>
<li>查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会 有两个Driver对象。</li>
<li>程序依赖mysql的api，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。</li>
</ul>
<p>推荐方式：&#x3D;&#x3D;Class.forName(“com.mysql.jdbc.Driver”);&#x3D;&#x3D;</p>
<p>采用此种方式不会导致驱动对象在内存中重复出现，并且采用此种方式，程序仅仅只需要一个字符串， 不需要依赖具体的驱动，使程序的灵活性更高。</p>
<blockquote>
<p>数据库URL讲解</p>
</blockquote>
<p>常用数据库URL地址的写法： </p>
<ul>
<li>Oracle写法：jdbc:oracle:thin:@localhost:1521:sid</li>
<li>SqlServer写法：jdbc:microsoft:sqlserver:&#x2F;&#x2F;localhost:1433; DatabaseName&#x3D;sid</li>
<li>MySql写法：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sid</li>
</ul>
<p>如果连接的是本地的Mysql数据库，并且连接使用的端口是3306，那么的url地址可以简写为</p>
<p>&#x3D;&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库&#x3D;&#x3D;</p>
<blockquote>
<p>Statement、PrepareStatement 执行SQL的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line"></span><br><span class="line">statement.executeQuert();<span class="comment">//查询操作返回ResultSet</span></span><br><span class="line">statement.execute();<span class="comment">//执行任何SQL</span></span><br><span class="line">statement.executeUpdate();<span class="comment">//更新、插入、删除。都用这个，返回一个受影响的行数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ResultSet 查询的结果集：封装了所有的查询结果</p>
</blockquote>
<p>获得指定的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resultSet.getObject();<span class="comment">//在不知道列类型的情况下使用</span></span><br><span class="line"><span class="comment">//知道列的类型就使用指定的类型</span></span><br><span class="line">resultSet.getString();</span><br></pre></td></tr></table></figure>

<p>遍历，指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next()：移动到下一行</span><br><span class="line">previous()：移动到前一行</span><br><span class="line">absolute(<span class="type">int</span> row)：移动到指定行</span><br><span class="line">beforeFirst()：移动resultSet的最前面。</span><br><span class="line">afterLast() ：移动到resultSet的最后面。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>释放资源</p>
</blockquote>
<p>Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通 常是ResultSet, Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后 必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则 是尽量晚创建，尽量早的释放。</p>
<p>为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。</p>
<h2 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h2><p>Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象 向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sql语句，executeUpdate执行 完后，将会返回一个整数（即增删改语句导致了数据库几行数据发生了变化）。 Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的 ResultSet对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//读取db.properties文件中的数据库连接信息</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">            JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(in);</span><br><span class="line">            <span class="comment">//获取数据库连接驱动</span></span><br><span class="line">            driver = prop.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">            <span class="comment">//获取数据库连接URL地址</span></span><br><span class="line">            url = prop.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            <span class="comment">//获取数据库连接用户名</span></span><br><span class="line">            username = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="comment">//获取数据库连接密码</span></span><br><span class="line">            password = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="comment">//加载数据库驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取数据库连接对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">    	<span class="keyword">return</span> DriverManager.getConnection(url, username,password);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 释放资源，要释放的资源包括Connection数据库连接对象，负责执行SQL命令的Statement对象，存储查询结果的ResultSet对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn,Statement st,ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭存储查询结果的ResultSet对象</span></span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            rs = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭负责执行SQL命令的Statement对象</span></span><br><span class="line">                st.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭Connection数据库连接对象</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PreparedStatement对象"><a href="#PreparedStatement对象" class="headerlink" title="PreparedStatement对象"></a>PreparedStatement对象</h2><p>PreperedStatement是Statement的子类，它的实例对象可以通过调用 Connection.preparedStatement()方法获得，相对于Statement对象而言：PreperedStatement可以避 免SQL注入的问题。 Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。 PreparedStatement可对SQL进行预编译，从而提高数据库的执行效率。并且PreperedStatement对于 sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsert</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取一个数据库连接</span></span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            <span class="comment">//要执行的SQL命令，SQL中的参数使用?作为占位符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(id,name,password,email,birthday)</span></span><br><span class="line"><span class="string">            values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">            <span class="comment">//通过conn对象获取负责执行SQL命令的prepareStatement对象</span></span><br><span class="line">            st = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//为SQL语句中的参数赋值，注意，索引是从1开始的</span></span><br><span class="line">            st.setInt(<span class="number">1</span>, <span class="number">4</span>);<span class="comment">//id是int类型的</span></span><br><span class="line">            st.setString(<span class="number">2</span>, <span class="string">&quot;kuangshen&quot;</span>);<span class="comment">//name是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">3</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//password是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">4</span>, <span class="string">&quot;24736743@qq.com&quot;</span>);<span class="comment">//email是varchar(字符串类型)</span></span><br><span class="line">            st.setDate(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span></span><br><span class="line">            <span class="title class_">Date</span>().getTime()));<span class="comment">//birthday是date类型</span></span><br><span class="line">            <span class="comment">//执行插入操作，executeUpdate方法返回成功的条数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> st.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入成功！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//SQL执行完成之后释放相关资源</span></span><br><span class="line">            JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免sql注入，原理：执行的时候参数会用引号包起来，并把参数中的引号作为转义字符，从而避免了参数也作为条件 的一部分。</p>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>&#x3D;&#x3D;ACID原则&#x3D;&#x3D;</p>
<ul>
<li><p>原子性：要么全部完成，要么都不完成</p>
</li>
<li><p>一致性：总数不变</p>
</li>
<li><p><strong>隔离性</strong>：多个进程互补干扰</p>
</li>
<li><p>持久性：一旦提交不可逆，持久化到数据库</p>
</li>
</ul>
<p>隔离性问题：</p>
<ul>
<li>脏读：脏读指一个事务读取了另外一个事务未提交的数据。</li>
<li>不可重复读：不可重复读指在一个事务内读取表中的某一行数据，多次读取结果不同。</li>
<li>虚读(幻读) : 虚读(幻读)是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</li>
</ul>
<blockquote>
<p>代码测试</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建账户表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">    money <span class="type">FLOAT</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/*插入测试数据*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;B&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;C&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>当Jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交 在它上面发送的SQL语句。若想关闭这种默认提交方式，让多条SQL在一个事务中执行，可使用下列的 JDBC控制事务语句。</p>
<ul>
<li>Connection.setAutoCommit(false);&#x2F;&#x2F;开启事务(start transaction)</li>
<li>Connection.rollback();&#x2F;&#x2F;回滚事务(rollback)</li>
<li>Connection.commit();&#x2F;&#x2F;提交事务(commit)</li>
</ul>
<blockquote>
<p>程序编写</p>
</blockquote>
<ul>
<li>开启事务 &#x3D;&#x3D;conn.setAutoCommit(false)&#x3D;&#x3D;</li>
<li>一组业务执行完毕，提交事务</li>
<li>可以在catch语句中显示的定义回滚语句，但默认失败就会回滚</li>
</ul>
<p>模拟转账成功时的业务场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟转账成功时的业务场景</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransaction1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//通知数据库开启事务(start transaction)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money-100 where</span></span><br><span class="line"><span class="string">            name=&#x27;A&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql1);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money+100 where</span></span><br><span class="line"><span class="string">            name=&#x27;B&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql2);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            conn.commit();<span class="comment">//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成功！！！&quot;</span>); <span class="comment">//log4j</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟转账过程中出现异常导致有一部分SQL执行失败后让数据库自动回滚事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟转账过程中出现异常导致有一部分SQL执行失败后让数据库自动回滚事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransaction2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//通知数据库开启事务(start transaction)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money-100 where</span></span><br><span class="line"><span class="string">            name=&#x27;A&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql1);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            <span class="comment">//用这句代码模拟执行完SQL1之后程序出现了异常而导致后面的SQL无法正常执行，事</span></span><br><span class="line">            务也无法正常提交，此时数据库会自动执行回滚操作</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money+100 where</span></span><br><span class="line"><span class="string">            name=&#x27;B&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql2);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            conn.commit();<span class="comment">//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成功！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//如果失败，默认回滚</span></span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟转账过程中出现异常导致有一部分SQL执行失败时手动通知数据库回滚事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟转账过程中出现异常导致有一部分SQL执行失败时手动通知数据库回滚事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransaction3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//通知数据库开启事务(start transaction)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money-100 where</span></span><br><span class="line"><span class="string">            name=&#x27;A&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql1);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            <span class="comment">//用这句代码模拟执行完SQL1之后程序出现了异常而导致后面的SQL无法正常执行，事</span></span><br><span class="line">            务也无法正常提交</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money+100 where</span></span><br><span class="line"><span class="string">            name=&#x27;B&#x27;&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql2);</span><br><span class="line">            st.executeUpdate();</span><br><span class="line">            conn.commit();<span class="comment">//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成功！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//捕获到异常之后手动通知数据库执行回滚事务的操作</span></span><br><span class="line">                conn.rollback();</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">        		e1.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也 较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并 且极易造成数据库服务器内存溢出、拓机。</p>
<blockquote>
<p>数据库连接池的基本概念</p>
</blockquote>
<p>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库 连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标。数据库连接池正式针对 这个问题提出来的。<strong>数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的 数据库连接,而不是重新建立一个</strong>。</p>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数 据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量. 连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数 超过最大连接数量时,这些请求将被加入到等待队列中. 数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素: 1. 最小连接数:是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有 大量的数据库连接资源被浪费. 2. 最大连接数:是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将 被加入到等待队列中,这会影响以后的数据库操作 3. 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接 请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被 释放,他将被放到连接池中等待重复使用或是空间超时后被释放.。</p>
<p>&#x3D;&#x3D;编写连接池需实现java.sql.DataSource接口。&#x3D;&#x3D;</p>
<blockquote>
<p>开源数据库连接池</p>
</blockquote>
<p>现在很多WEB服务器(Weblogic, WebSphere, Tomcat)都提供了DataSoruce的实现，即连接池的实现。 通常我们把DataSource的实现，按其英文含义称之为数据源，数据源中都包含了数据库连接池的实现。</p>
<p> 也有一些开源组织提供了数据源的独立实现： </p>
<ul>
<li>DBCP 数据库连接池 </li>
<li>C3P0 数据库连接池</li>
</ul>
<p>在使用了数据库连接池之后，在项目的实际开发中就不需要编写连接数据库的代码了，直接从数据源获得数据库的连接。</p>
<h3 id="DBCP数据源"><a href="#DBCP数据源" class="headerlink" title="DBCP数据源"></a>DBCP数据源</h3><p>DBCP 是 Apache 软件基金组织下的开源连接池实现，要使用DBCP数据源，需要应用程序应在系统中增 加如下两个 jar 文件：</p>
<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
<p>Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由 应用程序独立使用。</p>
<p>测试：</p>
<p>1、导入相关jar包</p>
<p>2、在类目录下加入dbcp的配置文件：dbcpconfig.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#连接设置</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbcStudy?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp;characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">#&lt;!-- 初始化连接 --&gt;</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#最大连接数量</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">50</span></span><br><span class="line"><span class="comment">#&lt;!-- 最大空闲连接 --&gt;</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#&lt;!-- 最小空闲连接 --&gt;</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]</span></span><br><span class="line"><span class="comment">#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。</span></span><br><span class="line"><span class="attr">connectionProperties</span>=<span class="string">useUnicode=true;characterEncoding=UTF8</span></span><br><span class="line"><span class="comment">#指定由连接池所创建的连接的自动提交（auto-commit）状态。</span></span><br><span class="line"><span class="attr">defaultAutoCommit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#driver default 指定由连接池所创建的连接的只读（read-only）状态。</span></span><br><span class="line"><span class="comment">#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：</span></span><br><span class="line"><span class="attr">Informix）</span></span><br><span class="line"><span class="attr">defaultReadOnly</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。</span></span><br><span class="line"><span class="comment">#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED,</span></span><br><span class="line"><span class="attr">REPEATABLE_READ,</span> <span class="string">SERIALIZABLE</span></span><br><span class="line"><span class="attr">defaultTransactionIsolation</span>=<span class="string">READ_UNCOMMITTED</span></span><br></pre></td></tr></table></figure>

<p>3、编写工具类 JdbcUtils_DBCP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSourceFactory;</span><br><span class="line"><span class="comment">//数据库连接工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils_DBCP</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在java中，编写数据库连接池需实现java.sql.DataSource接口，每一种数据库连接池都</span></span><br><span class="line"><span class="comment">    是DataSource接口的实现</span></span><br><span class="line"><span class="comment">    * DBCP连接池就是java.sql.DataSource接口的一个具体实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//在静态代码块中创建数据库连接池</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加载dbcpconfig.properties配置文件</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcpconfig.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(in);</span><br><span class="line">            <span class="comment">//创建数据源</span></span><br><span class="line">            ds = BasicDataSourceFactory.createDataSource(prop);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从数据源中获取数据库连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="comment">//从数据源中获取数据库连接</span></span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn,Statement st,ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭存储查询结果的ResultSet对象</span></span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            rs = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭负责执行SQL命令的Statement对象</span></span><br><span class="line">                st.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//将Connection连接对象还给数据库连接池</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.datasource.utils.JdbcUtils_DBCP;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBCPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取数据库连接</span></span><br><span class="line">            conn = JdbcUtils_DBCP.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(id,name,password,email,birthday)</span></span><br><span class="line"><span class="string">                values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">            st = conn.prepareStatement(sql);</span><br><span class="line">            st.setInt(<span class="number">1</span>, <span class="number">5</span>);<span class="comment">//id是int类型的</span></span><br><span class="line">            st.setString(<span class="number">2</span>, <span class="string">&quot;kuangshen&quot;</span>);<span class="comment">//name是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">3</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//password是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">4</span>, <span class="string">&quot;24736743@qq.com&quot;</span>);<span class="comment">//email是varchar(字符串类型)</span></span><br><span class="line">            st.setDate(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span></span><br><span class="line">                                            <span class="title class_">Date</span>().getTime()));<span class="comment">//birthday是date类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> st.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            JdbcUtils_DBCP.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目 前使用它的开源项目有Hibernate，Spring等。C3P0数据源在项目开发中使用得比较多。</p>
<p>c3p0与dbcp区别</p>
<ul>
<li>dbcp没有自动回收空闲连接的功能</li>
<li>c3p0有自动回收空闲连接功能</li>
</ul>
<p>测试：</p>
<p>1、导入相关jar包</p>
<p>2、在类目录下加入C3P0的配置文件：c3p0-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">C3P0的缺省(默认)配置，</span></span><br><span class="line"><span class="comment">如果在代码中“ComboPooledDataSource ds = new ComboPooledDataSource();”这样写</span></span><br><span class="line"><span class="comment">就表示使用的是C3P0的缺省(默认)配置信息来创建数据源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/jdbcStudy?</span><br><span class="line">            useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>useSSL=true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">C3P0的命名配置，</span></span><br><span class="line"><span class="comment">如果在代码中“ComboPooledDataSource ds = new</span></span><br><span class="line"><span class="comment">ComboPooledDataSource(&quot;MySQL&quot;);”这样写就表示使用的是name是MySQL的配置信息来创建数据</span></span><br><span class="line"><span class="comment">源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/jdbcStudy?</span><br><span class="line">            useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>useSSL=true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、创建工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="comment">//数据库连接工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils_C3P0</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//在静态代码块中创建数据库连接池</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//通过代码创建C3P0数据库连接池</span></span><br><span class="line">            <span class="comment">/*ds = new ComboPooledDataSource();</span></span><br><span class="line"><span class="comment">                ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line"><span class="comment">                ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/jdbcstudy&quot;);</span></span><br><span class="line"><span class="comment">                ds.setUser(&quot;root&quot;);</span></span><br><span class="line"><span class="comment">                ds.setPassword(&quot;123456&quot;);</span></span><br><span class="line"><span class="comment">                ds.setInitialPoolSize(10);</span></span><br><span class="line"><span class="comment">                ds.setMinPoolSize(5);</span></span><br><span class="line"><span class="comment">                ds.setMaxPoolSize(20);*/</span></span><br><span class="line">            <span class="comment">//通过读取C3P0的xml配置文件创建数据源，C3P0的xml配置文件c3p0-config.xml,必须放在			src目录下</span></span><br><span class="line">            <span class="comment">//ds = new ComboPooledDataSource();//使用C3P0的默认配置来创建数据源</span></span><br><span class="line">            ds = <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;MySQL&quot;</span>);<span class="comment">//使用C3P0的命名配置来创建数据源</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从数据源中获取数据库连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="comment">//从数据源中获取数据库连接</span></span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn,Statement st,ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭存储查询结果的ResultSet对象</span></span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            rs = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//关闭负责执行SQL命令的Statement对象</span></span><br><span class="line">                st.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//将Connection连接对象还给数据库连接池</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.datasource.utils.JdbcUtils_C3P0;</span><br><span class="line"><span class="keyword">import</span> com.kuang.datasource.utils.JdbcUtils_DBCP;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取数据库连接</span></span><br><span class="line">            conn = JdbcUtils_C3P0.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(id,name,password,email,birthday)</span></span><br><span class="line"><span class="string">                values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">                st = conn.prepareStatement(sql);</span><br><span class="line">            st.setInt(<span class="number">1</span>, <span class="number">6</span>);<span class="comment">//id是int类型的</span></span><br><span class="line">            st.setString(<span class="number">2</span>, <span class="string">&quot;kuangshen&quot;</span>);<span class="comment">//name是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">3</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//password是varchar(字符串类型)</span></span><br><span class="line">            st.setString(<span class="number">4</span>, <span class="string">&quot;24736743@qq.com&quot;</span>);<span class="comment">//email是varchar(字符串类型)</span></span><br><span class="line">            st.setDate(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span></span><br><span class="line">                                            <span class="title class_">Date</span>().getTime()));<span class="comment">//birthday是date类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> st.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            JdbcUtils_C3P0.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="连接配置优化"><a href="#连接配置优化" class="headerlink" title="连接配置优化"></a>连接配置优化</h2><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><ul>
<li>增加可用连接数，修改环境变量<code>max_connections</code>，默认情况下服务端的最大连接数为151个</li>
<li>及时释放不活动的连接，系统默认的客户端超时时间是28800秒（8小时），可以把这个值调小一点</li>
</ul>
<h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><ul>
<li>使用连接池<ul>
<li><code>Druid</code>的默认最大连接池大小是8，<code>Hikari</code>默认最大连接池大小是10，盲目地加大连接池的大小，系统执行效率反而可能降低。因为对于每一个连接，服务端会创建一个单独的线程去处理，连接数越多，服务端创建的线程自然也就越多。而线程数超过CPU个数的情况下，CPU势必要用过分配时间片的方式进行线程的上下文切换，频繁的上下文切换会造成很大的性能开销。</li>
<li><code>Hikari</code>官方给出了一个数据库连接池大小的建议值公式，CPU核心数 * 2 + 1。假设服务器的CPU核心数是4，把连接池设置成9就可以了。</li>
</ul>
</li>
</ul>
<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><ul>
<li><p>使用缓存</p>
</li>
<li><p>读写分离（集群、主从赋值）</p>
<ul>
<li>如何保持多个节点之间数据一致性——<strong>主从复制</strong>，<code>binlog</code>是实现MySQL主从复制功能的核心组件。master会将所有的写操作记录到binlog中，slave节点会有专门的<code>I/O</code>线程读取mastrer节点的binlog，将写操作同步到当前所在的slave节点。</li>
</ul>
</li>
<li><p>分库分表</p>
<blockquote>
<p>某张表的数据量急剧增加，单表的查询性能大幅下降，这个问题是读写分离也无法解决的，因为所有节点存放的是一模一样的数据，单表查询性能差，就是所有节点性能都差。这是可以把单个节点的数据分散到多个节点上进行存储，这就是<strong>分库分表</strong>。</p>
</blockquote>
<ul>
<li>垂直分库：在单体数据库的基础上垂直切几刀，按照业务逻辑拆分成不同的数据库。</li>
<li>垂直分表：在单表的基础上垂直切一刀（或几刀），将一个表的多个字段拆成若干个小表，这种操作需要根据具体业务来进行判断，通常会把经常使用的字段（热字段）分成一个表，不经常使用或者不立即使用的字段（冷字段）分成一个表，提升查询速度。</li>
<li>水平分表：把单张表的数据按照一定的规则（分片规则）保存到多个数据表上，横着给数据表来一刀，就是水平分表。</li>
<li>水平分库：就是对单个数据库水平切一刀，往往盘随着水平分表。</li>
</ul>
</li>
</ul>
<p>​		水平分，主要为了解决存储的瓶颈；垂直分，主要为了减轻并发压力。</p>
<h2 id="消息队列削峰"><a href="#消息队列削峰" class="headerlink" title="消息队列削峰"></a>消息队列削峰</h2><h2 id="优化器——SQL分析与优化"><a href="#优化器——SQL分析与优化" class="headerlink" title="优化器——SQL分析与优化"></a>优化器——SQL分析与优化</h2><ul>
<li><p>慢查询</p>
<blockquote>
<p>慢查询，MySQL默认关闭慢查询日志功能，使用<code>show variables like &#39;slow_query%&#39;;</code>命令查看当前慢查询状态，<code>slow_query_log</code>表示当前慢查询日志是否开启，<code>slow_query_log_file</code>表示慢查询日志的保存位置。默认超过10秒算是慢查询，如果改成0就是记录所有的SQL。<code>show variables like &#39;%long_query%&#39;</code></p>
</blockquote>
<ul>
<li><p>打开慢日志</p>
<ul>
<li><p>修改my.cnf，此种修改方式系统重启后依然有效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启慢查询日志</span></span><br><span class="line">slow_query_log=ON</span><br><span class="line">long_query_time=2</span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态修改参数（重启后失效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> @@global.slow_query_log=1</span><br><span class="line">mysql&gt; <span class="built_in">set</span> @@global.long_query_time=2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>慢日志分析：通过慢日志查询工具<code>mysqldumpslow</code>，其中</p>
<ul>
<li><p>Count：表示这个SQL执行的次数</p>
</li>
<li><p>Time：表示执行的时间，括号中的是累积时间</p>
</li>
<li><p>Locks：表示锁定的时间，括号中的是累积时间</p>
</li>
<li><p>Rows：表示返回的记录数，括号中的是累积数</p>
<p>更多<code>mysqldumpslow</code>的使用方式，可以查询官方文档，或者执行<code>mysqldumpslow --help</code>寻求帮助</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查看运行中的线程</p>
<blockquote>
<p>可以运行<code>show full processlist</code>查看MySQL中运行的所有线程，查看其状态和运行时间，找到不顺眼的，直接kill。其中：</p>
</blockquote>
<ul>
<li>Id：线程的唯一标志，可以使用Id杀死指定线程</li>
<li>User：启动这个线程的用户，普通账户只能查看自己的线程</li>
<li>Host：哪个IP和端口发起的连接</li>
<li>db：线程操作的数据库</li>
<li>Command：线程的命令</li>
<li>Time：操作持续时间，单位秒</li>
<li>State：线程的状态</li>
<li>Info：SQL语句的前100个字符</li>
</ul>
</li>
<li><p>查看服务器的运行状态</p>
</li>
<li><p>查看服务器运行状态</p>
<p>使用<code>SHOW TATUS</code>查看MySQL服务器的运行状态，有session和global两种作用域，一般使用like+通配符进行过滤。</p>
<p><code>SHOW GLOBAL STATUS LIKE &#39;com_select&#39;</code>。</p>
</li>
<li><p>查看存储引擎运行信息</p>
<p><code>SHOW ENGINE</code>用来展示存储引擎的当前运行信息，包括事务持有的表锁、行锁信息；事务的锁等待情况；线程信号量等待；文件IO请求；Buffer pool统计信息等等数据。如：<code>SHOW ENGINE INNODB STATUS</code>，这条语句可以展示innodb存储引擎的当前运行的各种信息，可以据此找到MySQL当前的问题</p>
</li>
<li><p>EXPLAIN执行计划</p>
</li>
<li><p>SQL和索引优化</p>
<ul>
<li><p>小表驱动大表：用join改写子查询：or改成union</p>
</li>
<li><p>连接查询中，访问被驱动表的成本要尽量低，尽量在被驱动表的连接列上建立索引，降低访问成本；被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样被驱动表的成本会降到更低</p>
</li>
<li><p>大偏移量的limit，先过滤再排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.大偏移量的查询</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">9000000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 2.先过滤ID（因为ID使用的是索引），再limit</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">9000000</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="存储引擎和表结构"><a href="#存储引擎和表结构" class="headerlink" title="存储引擎和表结构"></a>存储引擎和表结构</h2><ul>
<li><p>选择存储引擎</p>
<blockquote>
<p>一般情况下，选择MySQL默认的存储引擎InnoDB，但是当对数据库性能要求精益求精的时候，存储引擎的选择也成为一个关键的影响因素。可根据不同的业务选择不同的存储引擎，例如：</p>
</blockquote>
<ul>
<li><p>查询操作、插入操作多的业务表，推荐使用MyISAM；</p>
</li>
<li><p>临时表使用Menory；</p>
</li>
<li><p>并发数量大，更新多的业务选择使用InnoDB；</p>
</li>
</ul>
</li>
<li><p>优化字段</p>
<ul>
<li>非空字段尽量设置成NOT NULL，并提供默认值，或者使用特殊值代替NULL，因为NULL类型的存储和优化都会存在性不佳的问题。</li>
<li>不要用外键、触发器和视图功能。原因有三个：1. 降低了可读性；2. 把计算的工作交给程序，数据库只做好存储的工作；3. 数据的完整性校验的工作应该由开发者完成，而不是依赖于外键，一旦用了外键，会发现测试的时候随便删点垃圾数据都变得异常艰难</li>
</ul>
</li>
<li><p>图片、音频、视频存储：不要直接存储大文件，而是要存储大文件的访问地址。</p>
</li>
<li><p>大字段拆分和数据冗余</p>
<ul>
<li>大字段拆分就是垂直分表，把不常用的字段或者数据量较大的字段拆分出去，避免列数过多和数据量过大。</li>
<li>字段冗余原则上不符合数据库设计范式，但是非常有利于快速检索。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/09/29/Linux/</url>
    <content><![CDATA[<h1 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_341</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>

<h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前所有tcp端口</span></span><br><span class="line">netstat -ntlp</span><br><span class="line"><span class="comment"># 查看所有8080端口使用情况</span></span><br><span class="line">netstat -ntulp | grep 8080</span><br><span class="line"><span class="comment"># 开发指定端口（如1935）</span></span><br><span class="line"><span class="comment"># --zone 作用域</span></span><br><span class="line"><span class="comment"># --add-port=1935/tcp 添加端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="comment"># --permanent 永久生效，没有此参数重启后失效</span></span><br><span class="line">firewall-cmd --zone=public --add-port=1935/tcp --permanent</span><br></pre></td></tr></table></figure>

<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment"># 禁用</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"><span class="comment"># 停止并禁止开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status firewalld 或者 firewall-cmd --state</span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure>

<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将服务设置为每次开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># 服务立即启动 下次不启动</span></span><br><span class="line">systemctl start</span><br><span class="line"><span class="comment"># 立即启动且每次重启也启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now   </span><br></pre></td></tr></table></figure>

<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看crontab服务状态</span></span><br><span class="line">service crond status</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">service crond start</span><br><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line">service crond stop</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">service crond restart</span><br><span class="line"><span class="comment"># 重新载入配置</span></span><br><span class="line">service crond reload</span><br></pre></td></tr></table></figure>

<p><strong>配置定时任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/crontab</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每分钟执行一次</span></span><br><span class="line">*/1 * * * * root sh /opt/test.sh &gt;&gt; /opt/test.log</span><br></pre></td></tr></table></figure>

<h1 id="修改交换内存"><a href="#修改交换内存" class="headerlink" title="修改交换内存"></a>修改交换内存</h1><ol>
<li><p>查看内存交换空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个大小为500M的swapfile文件</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=swapfile bs=1024 count=500000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在root权限下，创建swapfile (有时会遇到dd命令不识别 可能是你安装过一次了 那就先把swapfile删除。）像&#x2F;dev&#x2F;null一样， &#x2F;dev&#x2F;zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。&#x2F;dev&#x2F;zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。</p>
</blockquote>
<ol start="3">
<li><p>将swapfile设置为swap空间（把这个文件变成swap文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用交换空间（启用这个swap文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除交换空间命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff swapfile</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql命令</title>
    <url>/2022/08/31/Mysql%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h4><h5 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h5><blockquote>
<p>检查电脑是否预装了mysql（预装的mysql叫mariadb ），有则卸载删除</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mariadb  #查询是否预装mysql</span><br><span class="line"> </span><br><span class="line">rpm -e --nodeps mariadb-libs  #有返回数据则使用该命令卸载</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传解压</p>
</blockquote>
<p>解压后改名，放到指定目录下</p>
<h5 id="准备MySQL用户及用户组，完成相关配置"><a href="#准备MySQL用户及用户组，完成相关配置" class="headerlink" title="准备MySQL用户及用户组，完成相关配置"></a>准备MySQL用户及用户组，完成相关配置</h5><blockquote>
<p>添加MySQL用户和组</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd mysql   #添加名为mysql的用户组</span><br><span class="line"> </span><br><span class="line">useradd -r -g mysql mysql   #添加名为mysql的用户，并将其添加到mysql组中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建MySQL数据和日志文件夹并授权</p>
</blockquote>
<p>在mysql目录下，新建数据目录data和日志目录logs，并改变其所有者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir data   #创建mysql数据目录</span><br><span class="line">mkdir logs</span><br><span class="line"> </span><br><span class="line">chown mysql:mysql -R /usr/local/mysql  #将mysql数据目录的所有者和所有组改为mysql用户和组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用vim命令编辑&#x2F;etc&#x2F;my.cnf</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#skip-grant-tables</span></span><br><span class="line"><span class="comment">#default_password_lifetime=90</span></span><br><span class="line"><span class="attr">bind-address</span>=<span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment">#mysql监听的ip地址，如果是127.0.0.1，表示仅本机访问，0.0.0.0表示全地址可以访问（任何主机）</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306  #mysql运行在哪个端口</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">mysql  #mysql以什么用户运行</span></span><br><span class="line"><span class="comment">#max_allowed_packet=10000000</span></span><br><span class="line"><span class="attr">basedir</span>=<span class="string">/usr/local/mysql  #mysql主目录</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">/usr/local/mysql/data  #mysql的数据目录</span></span><br><span class="line"><span class="attr">socket</span>=<span class="string">/var/lib/mysql/mysql.sock   #mysql以socket方式运行的sock文件位置</span></span><br><span class="line"><span class="attr">log-error</span>=<span class="string">/usr/local/mysql/data/mysql.err  #错误日志位置</span></span><br><span class="line"><span class="attr">pid-file</span>=<span class="string">/usr/local/mysql/data/mysql.pid   #进程id文件</span></span><br><span class="line"><span class="comment">#character config</span></span><br><span class="line"><span class="attr">character_set_server</span>=<span class="string">utf8mb4  #服务器使用的字符集</span></span><br><span class="line"><span class="attr">symbolic-links</span>=<span class="string">0   #是否支持符号链接，即数据库或表可以存储在my.cnf中指定datadir之外的分区或目录，为0不开启</span></span><br><span class="line"><span class="attr">explicit_defaults_for_timestamp</span>=<span class="string">true  #mysql中TIMESTAMP类型和其他的类型有点不一样(在没有设置explicit_defaults_for_timestamp=1的情况下）</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="string">1000</span></span><br><span class="line"><span class="attr">group_concat_max_len</span> = <span class="string">102400</span></span><br><span class="line"><span class="attr">lower_case_table_names</span> = <span class="string">1</span></span><br><span class="line"><span class="attr">log_bin_trust_function_creators</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span></span><br><span class="line"><span class="attr">transaction_isolation</span> = <span class="string">READ-COMMITTED</span></span><br><span class="line"><span class="attr">open-files-limit</span> = <span class="string">65535</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据库初始化</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin #先cd到bin目录</span><br><span class="line"> </span><br><span class="line">./mysqld --initialize --user=mysql #mysql初始化命令，必须在bin目录下使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置MySQL服务，启动MySQL</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql  #添加mysql服务</span><br><span class="line"> </span><br><span class="line">service mysql start   #启动mysql</span><br><span class="line"></span><br><span class="line">ln -s /usr/local/mysql/bin/mysql /usr/bin	#创建软连接</span><br></pre></td></tr></table></figure>

<h5 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h5><blockquote>
<p>登录数据库，更换root密码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p   #以root用户登录mysql</span><br></pre></td></tr></table></figure>

<p>如果出现<code>Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code>的错误，建立一个软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /var/lib/mysql/mysql.sock /tmp/mysql.sock 	<span class="comment">#创建软连接</span></span><br></pre></td></tr></table></figure>

<p>修改密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql5<span class="number">.7</span>之前</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">mysql5<span class="number">.7</span>之后</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>也可以：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;你要设置的密码&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>设置密码永不过期以及其他客户端连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span>, password_expired<span class="operator">=</span><span class="string">&#x27;N&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br><span class="line">mysql<span class="operator">&gt;</span> quit</span><br></pre></td></tr></table></figure>



<h4 id="主从复制搭建"><a href="#主从复制搭建" class="headerlink" title="主从复制搭建"></a>主从复制搭建</h4><blockquote>
<p>查看binlog是否开启</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysq<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启binlog，主从都要开启，配置完重启</strong></p>
<blockquote>
<p>master的配置文件</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server_id</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">log_bin</span>=<span class="string">mysql-bin</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>slave的配置文件</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server_id</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">log_bin</span>=<span class="string">mysql-bin</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br><span class="line"></span><br><span class="line"><span class="attr">relay-log</span>=<span class="string">mysql-relay-bin #relay-log为主库的操作日志</span></span><br><span class="line"><span class="attr">replicate-wild-ignore-table</span>=<span class="string">mysql.% #忽略mysql自带的表</span></span><br><span class="line"><span class="attr">replicate-wild-ignore-table</span>=<span class="string">test.% #忽略test表</span></span><br><span class="line"><span class="attr">replicate-wild-ignore-table</span>=<span class="string">information_schema.% #忽略information——schema表</span></span><br><span class="line"><span class="attr">replicate_do_db</span>=<span class="string">mcportal #在slave上配置，指定slave要复制哪个库</span></span><br><span class="line"><span class="attr">replicate-ignore-db</span>=<span class="string">mysql,performance_schema,information_schema #在slave上配置，指定slave要复制哪个库</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看binlog日志</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line">mysql<span class="operator">&gt;</span> reset master <span class="comment">-- 生产环境慎用（清楚binlog日志）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在主库上创建用于同步的账号</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysyxs&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;xxxx&#x27;</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;<span class="comment">-- 刷新权限</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为slave机器设置master的binlog文件以及位置信息</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;10.30.38.203&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;mysyxs&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;whitebox123!&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">154</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从机开启slave</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> slave; <span class="comment">-- 开启slave</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status\G <span class="comment">-- 查看状态</span></span><br><span class="line">mysql<span class="operator">&gt;</span> stop slave;</span><br></pre></td></tr></table></figure>



<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h5><p>查看MySQL提供什么存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p>查看MySQL当前默认的存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看看某个表用了什么引擎(在显示结果里参数engine后面的就表示该表当前用的存储引擎)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>

<h5 id="字符集与排序规则"><a href="#字符集与排序规则" class="headerlink" title="字符集与排序规则"></a>字符集与排序规则</h5><p><a href="https://blog.csdn.net/baidu_27169523/article/details/124470382">https://blog.csdn.net/baidu_27169523/article/details/124470382</a></p>
<p>简便的批量修改MySQL表的字符集和排序规则建库 指定字符集和排序规则：</p>
<p><a href="https://blog.csdn.net/qq_31766907/article/details/125784849">https://blog.csdn.net/qq_31766907/article/details/125784849</a></p>
<p>查看MYSQL数据库服务器和数据库字符集：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%character%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看库的字符集：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> database 数据库\G;</span><br></pre></td></tr></table></figure>

<p>查看表的字符集：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> 库名 <span class="keyword">like</span> 表名;</span><br></pre></td></tr></table></figure>

<p>建表指定字符集和排序规则：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> DATABASE `test` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>

<p>修改规则：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> DATABASE `test` <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>

<h5 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h5><p>创建用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;用户密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>配置权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> 数据库名.<span class="operator">*</span> <span class="keyword">to</span> 用户名@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;用户密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只读权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> <span class="keyword">Select</span> <span class="keyword">ON</span> `数据库名`.<span class="operator">*</span> <span class="keyword">TO</span> `zhongjiang`@`<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure>

<p>添加超级权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;yangxin&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;yangxin123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>

<ul>
<li>all privileges：表示将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。</li>
<li>on：表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写“*”表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user</li>
<li>to：将权限授予哪个用户。格式：”用户名”@”登录IP或域名”。%表示没有限制，在任何主机都可以登录。比如：”yangxin”@”192.168.0.%”，表示yangxin这个用户只能在192.168.0IP段登录</li>
<li>identified by：指定用户的登录密码</li>
</ul>
<p>回收权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;yangxin@localhost&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>

<p>删除用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> host,<span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;yangxin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>重命名用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> rename <span class="keyword">user</span> <span class="string">&#x27;test3&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">to</span> <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h5><p>连接远程命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> mysql <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.0</span><span class="number">.201</span> <span class="operator">-</span>p3306 <span class="operator">-</span>uroot <span class="operator">-</span>p123</span><br></pre></td></tr></table></figure>

<p>添加MySQL环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 既然属于mysql的bin目录下面，那我们可以把此目录配置环境变量中，再次执行命令也可以</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加mysql的环境变量</span></span><br><span class="line"><span class="built_in">export</span> MYSQL_HOME=/usr/local/mysql</span><br><span class="line"><span class="built_in">export</span> PATH=.:<span class="variable">$&#123;MYSQL_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="SSL连接"><a href="#SSL连接" class="headerlink" title="SSL连接"></a>SSL连接</h5><p>查看MySQL是否开启SSL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%ssl%&quot;;</span><br></pre></td></tr></table></figure>

<p>在mysql&#x2F;bin目录下有<code>mysql_ssl_rsa_setup</code>文件，执行它开始安装ssl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ./mysql_ssl_rsa_setup</span><br></pre></td></tr></table></figure>

<p>安装完成后，会生成一些私钥公钥在mysql&#x2F;data目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll *.pem</span><br><span class="line">-rw------- 1 mysql mysql 1675 Jun 12 17:22 ca-key.pem         <span class="comment">#CA私钥</span></span><br><span class="line">-rw-r--r-- 1 mysql mysql 1074 Jun 12 17:22 ca.pem             <span class="comment">#自签的CA证书，客户端连接也需要提供</span></span><br><span class="line">-rw-r--r-- 1 mysql mysql 1078 Jun 12 17:22 client-cert.pem    <span class="comment">#客户端连接服务器端需要提供的证书文件</span></span><br><span class="line">-rw------- 1 mysql mysql 1675 Jun 12 17:22 client-key.pem     <span class="comment">#客户端连接服务器端需要提供的私钥文件</span></span><br><span class="line">-rw------- 1 mysql mysql 1675 Jun 12 17:22 private_key.pem    <span class="comment">#私钥/公钥对的私有成员</span></span><br><span class="line">-rw-r--r-- 1 mysql mysql 451 Jun 12 17:22  public_key.pem     <span class="comment">#私钥/公钥对的共有成员</span></span><br><span class="line">-rw-r--r-- 1 mysql mysql 1078 Jun 12 17:22 server-cert.pem    <span class="comment">#服务器端证书文件</span></span><br><span class="line">-rw------- 1 mysql mysql 1675 Jun 12 17:22 server-key.pem     <span class="comment">#服务器端私钥文件</span></span><br></pre></td></tr></table></figure>

<p>修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R mysql.mysql *.pem</span><br></pre></td></tr></table></figure>

<p>添加ssl参数到<code>my.cnf</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">ssl-ca=/usr/local/mysql/data/ca.pem</span><br><span class="line">ssl-cert=/usr/local/mysql/data/client-cert.pem</span><br><span class="line">ssl-key=/usr/local/mysql/data/client-key.pem</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">ssl-ca=/usr/local/mysql/data/ca.pem</span><br><span class="line">ssl-cert=/usr/local/mysql/data/client-cert.pem</span><br><span class="line">ssl-key=/usr/local/mysql/data/client-key.pem</span><br></pre></td></tr></table></figure>

<p>重启MySQL</p>
<p>使用<code>\s</code>或<code>status</code>查看当前连接是否使用了ssl</p>
<p>强制用户使用ssl</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>新建用户</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;xxx&#x27;</span> REQUIRE SSL; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>修改用户</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;%&#x27;</span> REQUIRE SSL;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/sumengnan/article/details/114086217">https://blog.csdn.net/sumengnan/article/details/114086217</a></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenNMS</title>
    <url>/2022/12/05/OpenNMS/</url>
    <content><![CDATA[<p>OpenNMS :: Checkstyle</p>
<p>OpenNMS :: Core :: Systemproperties</p>
<p>OpenNMS :: Core :: SNMP :: API，OpenNMS :: Dependencies :: JAXB</p>
<p>org.opennms.dependencies:jaxb-dependencies:pom:32.0.0-SNAPSHOT, </p>
<p>org.opennms.core.snmp:org.opennms.core.snmp.api:jar:32.0.0-SNAPSHOT, org.opennms.features.collection:org.opennms.features.collection.api:jar:32.0.0-SNAPSHOT, </p>
<p>org.opennms.core:org.opennms.core.lib:jar:32.0.0-SNAPSHOT, </p>
<p>org.opennms.core:org.opennms.core.xml:jar:32.0.0-SNAPSHOT,</p>
<p> org.opennms.core.test-api:org.opennms.core.test-api.xml:jar:32.0.0-SNAPSHOT:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">agent</span> <span class="attr">address</span>=<span class="string">&quot;192.168.1.1&quot;</span> <span class="attr">store-by-fs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">node-id</span>=<span class="string">&quot;99&quot;</span> <span class="attr">node-label</span>=<span class="string">&quot;switch&quot;</span> <span class="attr">foreign-source</span>=<span class="string">&quot;fs&quot;</span> <span class="attr">foreign-id</span>=<span class="string">&quot;fid&quot;</span> <span class="attr">location</span>=<span class="string">&quot;HQ&quot;</span> <span class="attr">storage-resource-path</span>=<span class="string">&quot;tmp/foo&quot;</span> <span class="attr">sys-up-time</span>=<span class="string">&quot;149&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;k1&quot;</span>&gt;</span>&lt;![CDATA[v1]]&gt;<span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">agent</span> <span class="attr">address</span>=<span class="string">&quot;192.168.1.1&quot;</span> <span class="attr">store-by-fs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">node-id</span>=<span class="string">&quot;99&quot;</span> <span class="attr">node-label</span>=<span class="string">&quot;switch&quot;</span> <span class="attr">foreign-source</span>=<span class="string">&quot;fs&quot;</span> <span class="attr">foreign-id</span>=<span class="string">&quot;fid&quot;</span> <span class="attr">location</span>=<span class="string">&quot;HQ&quot;</span> <span class="attr">storage-resource-path</span>=<span class="string">&quot;tmp\foo&quot;</span> <span class="attr">sys-up-time</span>=<span class="string">&quot;149&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;k1&quot;</span>&gt;</span>&lt;![CDATA[v1]]&gt;<span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">agent</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>OpenNMS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL</title>
    <url>/2022/12/01/PostgreSQL/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>检车PostgreSQL是否已经安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查PostgreSQL是否已经安装</span></span><br><span class="line">rpm -qa | grep postgres</span><br><span class="line"><span class="comment"># 检查PostgreSQL安装位置</span></span><br><span class="line">rpm -qal | grep postgres</span><br></pre></td></tr></table></figure>

<p><strong>若已经安装，则使用<code>rpm -e</code>命令卸载</strong></p>
<p><strong>上传压缩包并解压</strong></p>
<p><code>postgresql-12.0.tar.gz</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf postgresql-12.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>准备</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增postgres用户组</span></span><br><span class="line">groupadd postgres</span><br><span class="line"><span class="comment"># 新增postgres用户并且设置这个用户属于上面创建的postgres用户组</span></span><br><span class="line">useradd -g postgres postgres</span><br><span class="line"><span class="comment"># 修改postgres用户密码（这里设置密码为postgres）</span></span><br><span class="line">passwd postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建安装路径和日志文件，并给用户分配权限</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/pgsql/data</span><br><span class="line"><span class="built_in">touch</span> /usr/local/pgsql/pgsql.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R postgres:postgres /usr/local/pgsql/</span><br></pre></td></tr></table></figure>

<p><strong>编译并安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/postgresql-12.0</span><br><span class="line">./configure --prefix=/usr/local/pgsql</span><br><span class="line"><span class="comment"># 如果出现configure: error: readline library not found。执行：</span></span><br><span class="line"><span class="comment"># yum install readline-devel</span></span><br><span class="line"><span class="comment"># 如果出现configure: error: zlib library not found。执行：</span></span><br><span class="line"><span class="comment"># yum install zlib-devel</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</span><br></pre></td></tr></table></figure>

<p>有以下内容输出则为成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Success. You can now start the database server using:</span><br><span class="line"></span><br><span class="line">	./pg_ctl -D /usr/local/pgsql/data -l logfile start</span><br></pre></td></tr></table></figure>

<p><strong>修改文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改访问配置文件pg_hba.conf</span></span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line">vim pg_hba.conf</span><br><span class="line">host	all		all		0.0.0.0/0		md5</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件postgresql.conf</span></span><br><span class="line">vim postgresql.conf</span><br><span class="line"><span class="comment"># 具体修改：</span></span><br><span class="line"><span class="comment"># 将 #listen_address = &#x27;localhost&#x27;改为listen_address= &#x27;*&#x27;</span></span><br><span class="line"><span class="comment"># 将 #port = 5432 前的#号去掉</span></span><br><span class="line"><span class="comment"># 将 #password_encryption 前的#号去掉</span></span><br></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化数据库并启动</span></span><br><span class="line">pg_ctl -D /usr/local/pgsql/data -l /usr/local/pgsql/pgsql.log start</span><br><span class="line">pg_ctl -D /usr/local/pgsql/data -l /usr/local/pgsql/logfile start</span><br><span class="line"> </span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">pg_ctl -D /usr/local/pgsql/data &gt; /usr/local/pgsql/pgsql.log 2&gt;&amp;1 &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#不带日志启动</span></span><br><span class="line">pg_ctl -D /usr/local/pgsql/data start</span><br></pre></td></tr></table></figure>

<p><strong>其他命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//关闭</span><br><span class="line">pg_ctl -D /opt/pgsql/data -l /opt/pgsql/logfile stop</span><br><span class="line"> </span><br><span class="line">//重启</span><br><span class="line">pg_ctl -D /opt/pgsql/data -l /opt/pgsql/logfile restart</span><br><span class="line"> </span><br><span class="line">//查看数据库状态</span><br><span class="line">pg_ctl -D /opt/pgsql/data status</span><br><span class="line"> </span><br><span class="line">//查看是否启动</span><br><span class="line">ps -A | grep postgres</span><br><span class="line">ps -aux | grep postgres</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">rpm -qa | grep postgres    检查PostgreSQL 是否已经安装</span><br><span class="line">rpm -qal | grep postgres   检查PostgreSQL 安装位置</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">alter user postgres with password <span class="string">&#x27;postgres&#x27;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Others</title>
    <url>/2022/09/27/Others/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/11/27/Redis/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><strong>加锁：</strong>加锁时要加上过期时间，加锁和设置过期时间必须时原子操作，否则可能死锁。</p>
<p><strong>续期：</strong>业务还没有完成，锁到了过期时间，此时要给锁续期，同时设置守护线程定时给锁续期。</p>
<p><strong>解锁：</strong>加锁和解锁必须时同一个人，对比加锁时设置的value，value相等才能解锁，对比操作和解锁操作需要原子操作。</p>
<p><strong>特征：</strong></p>
<ul>
<li>互斥性：任意时刻，只有一个客户端能持有锁。</li>
<li>锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li>
<li>可重入性：一个线程如果获取了锁之后,可以再次对其请求加锁。</li>
<li>高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li>
<li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除。</li>
</ul>
<p><strong>方案：</strong></p>
<ul>
<li><p>使用Lua脚本(包含SETNX + EXPIRE两条指令)</p>
<p>lua脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加锁代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">lua_scripts</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line"><span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SET的扩展命令（SET EX PX NX）——保证原子性</p>
<p>存在问题：</p>
<ul>
<li>锁过期释放了，业务还没执行完</li>
<li>锁被别的线程误删</li>
</ul>
</li>
<li><p>开源框架~Redisson</p>
<p><img src="/Redis%5Cimage-20221129111542941.png"></p>
<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了<strong>「锁过期释放，业务没执行完」</strong>问题。</p>
</li>
<li><p>方案七：多机实现的分布式锁Redlock</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ基础</title>
    <url>/2022/09/22/RocketMQ%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>消息队列是一种 &#x3D;&#x3D;先进先出&#x3D;&#x3D; 的数据结构</p>
<p><strong>优缺点</strong></p>
<blockquote>
<p>优点：</p>
</blockquote>
<ul>
<li>应用解耦</li>
<li>流量削峰</li>
<li>数据分发</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li><p>系统可用性降低：</p>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用？</p>
</li>
<li><p>系统复杂度提高：</p>
<p>MQ的加入大大增加了系统的复杂度，以前系统是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？怎么保证消息传递的顺序性？</p>
</li>
<li><p>一致性问题：</p>
<p>A系统处理完业务，通过MQ给B，C，D三个系统发送消息数据，如果B系统，C系统处理成功，D系统处理失败。如何保证消息数据处理的一致性？</p>
</li>
</ul>
<p><strong>各种MQ产品比较</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>kafka</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
<td>Scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>万级</td>
<td>10万级</td>
<td>10万级</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高（主从架构）</td>
<td>高（主从架构）</td>
<td>非常高（分布式架构）</td>
<td>非常高（分布式架构）</td>
</tr>
<tr>
<td>功能特性</td>
<td>成熟的产品，在很多公司得到应用；有较多的文档，各种协议支持较好</td>
<td>基于Erlang开发，所以并发能力很强，性能极其好，延时很低，管理界面叫丰富</td>
<td>MQ功能比较完善，扩展性佳</td>
<td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广</td>
</tr>
</tbody></table>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li><p>启动NameServer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动NameServer</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Broker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动Broker</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题描述：</p>
<p>RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑runserver.sh和runbroker.sh修改默认JVM大小</span></span><br><span class="line">vim runserver.sh</span><br><span class="line">vim runbroker.sh</span><br></pre></td></tr></table></figure>

<p>参考设置：</p>
<p><code>JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</code></p>
</li>
</ul>
<p>​		<code>JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m&quot;</code></p>
<ul>
<li><p>测试</p>
<ul>
<li><p>发送消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 使用安装包的Demo发送消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 接收消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关闭RockerMQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.关闭NameServer</span></span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"><span class="comment"># 2.关闭Broker</span></span><br><span class="line">sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><h2 id="各个角色"><a href="#各个角色" class="headerlink" title="各个角色"></a>各个角色</h2><ul>
<li>Producer：消息发送者，举例：发信者</li>
<li>Consumer：消息接收者，举例：收信者</li>
<li>Broker：暂存和传输消息，举例：邮局</li>
<li>NameServer：管理Broker，举例：各个邮局的管理机构</li>
<li>Topic：区分消息的种类，一个发送者可以发送消息给一个或多个Topic，一个消息接收者可以订阅一个或多个Topic消息</li>
<li>Message Queue：相当于Topic的分区；用于并行发送和接收消息</li>
</ul>
<h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><ul>
<li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步；</li>
<li>Broker部署相对复杂，Broker分为Master和Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master。Master和Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个，每个Broker和NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</li>
<li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li>
<li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</li>
</ul>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><ul>
<li><p>单Master模式</p>
<p>风险较大，一旦Broker重启或宕机时，会导致整个服务不可用。不建议线上环境使用，可用于本地测试。</p>
</li>
<li><p>多Master模式</p>
<p>一个集群无Slave，全是Master，例如两个Master或三个Master，这种模式有缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不丢失（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最好。</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息 在机器恢复前不可订阅，消息实时性会收到影响。</li>
</ul>
</li>
<li><p>多Master多Slave模式（&#x3D;&#x3D;异步&#x3D;&#x3D;）</p>
<p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同Master模式几乎一样。</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
</li>
<li><p>多Master多Slave模式（&#x3D;&#x3D;同步&#x3D;&#x3D;）</p>
<p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>
<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能字段切换为主机。</li>
</ul>
</li>
</ul>
<h2 id="双主双从集群搭建"><a href="#双主双从集群搭建" class="headerlink" title="双主双从集群搭建"></a>双主双从集群搭建</h2><h3 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h3><ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息（IP+端口等）以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Topic上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一条NameServer建立长连接，获取当前订阅Broker存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<h3 id="服务器准备工作"><a href="#服务器准备工作" class="headerlink" title="服务器准备工作"></a>服务器准备工作</h3><p><strong>服务器环境</strong></p>
<table>
<thead>
<tr>
<th>IP</th>
<th>角色</th>
<th>架构模式</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.25.135</td>
<td>nameserver、brokerserver</td>
<td>Master1、Slave2</td>
</tr>
<tr>
<td>192.168.25.138</td>
<td>nameserver、brokerserver</td>
<td>Master2、Slave1</td>
</tr>
</tbody></table>
<p><strong>host添加信息</strong></p>
<p>目的在于后面集群配置文件编写的时候，直接通过域名去访问节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/host</span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nameserver</span></span><br><span class="line">192.168.25.135 rockermq-nameserver1</span><br><span class="line">192.168.25.138 rockermq-nameserver2</span><br><span class="line"><span class="comment"># broker</span></span><br><span class="line">192.168.25.135 rockermq-master1</span><br><span class="line">192.168.25.135 rockermq-slave2</span><br><span class="line">192.168.25.138 rockermq-master2</span><br><span class="line">192.168.25.138 rockermq-slave1</span><br></pre></td></tr></table></figure>

<p>配置完成后，重启网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p><strong>防火墙配置</strong></p>
<p>宿主机需要远程访问虚拟机的rockermq服务和web服务，需要开发相关的端口号，简单粗暴的方式是直接关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 查看防火墙的装态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="comment"># 禁止防火墙开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>或者为了安全，只开放特定的端口号，RockerMQ默认使用3个端口：9876、10911、11011，如果防火墙没有关闭的话，那么必须开放这些端口：</p>
<ul>
<li><code>nameserver</code>：9876</li>
<li><code>master</code>：10911</li>
<li><code>slave</code>：11011</li>
</ul>
<p>执行一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开放nameserver默认端口</span></span><br><span class="line">firewall-cmd --remote-port=9876/tcp --permanent</span><br><span class="line"><span class="comment"># 开放master默认端口</span></span><br><span class="line">firewall-cmd --remote-port=10911/tcp --permanent</span><br><span class="line"><span class="comment"># 开放slave默认端口（当前集群模式可不开启）</span></span><br><span class="line">firewall-cmd --remote-port=11011/tcp --permanent</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p><strong>环境变量配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在profile文件的末尾加入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set rocketmq</span></span><br><span class="line">ROCKETMQ_HOME=/usr/local/rocketmq/rocketmq-all-4.4.0-bin-release</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME PATH</span><br></pre></td></tr></table></figure>

<p>保存退出，使配置立即生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p><strong>创建消息存储路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq/store</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq/store/commitlog</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq/store/consumequeue</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/rocketmq/store/index</span><br></pre></td></tr></table></figure>



<h3 id="broker配置文件"><a href="#broker配置文件" class="headerlink" title="broker配置文件"></a>broker配置文件</h3><h4 id="master1："><a href="#master1：" class="headerlink" title="master1："></a>master1：</h4><p>服务器：192.168.25.135</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment"># broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line"><span class="comment"># 0表示Master，&gt;0表示Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment"># nameServer地址，分号分隔</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment"># 是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Broker对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deletewhen=04</span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment"># commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment"># ConsumeQueue每个文件默认存30条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line"><span class="comment"># commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line"><span class="comment"># 消费队列存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line"><span class="comment"># checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment"># Broker的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h4 id="slave2："><a href="#slave2：" class="headerlink" title="slave2："></a>slave2：</h4><p>服务器：192.168.25.135</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment"># broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment"># 0表示Master，&gt;0表示Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment"># nameServer地址，分号分隔</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment"># 是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Broker对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deletewhen=04</span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment"># commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment"># ConsumeQueue每个文件默认存30条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line"><span class="comment"># commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line"><span class="comment"># 消费队列存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line"><span class="comment"># checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment"># Broker的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h4 id="master2"><a href="#master2" class="headerlink" title="master2"></a>master2</h4><p>服务器：192.168.25.138</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment"># broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment"># 0表示Master，&gt;0表示Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment"># nameServer地址，分号分隔</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment"># 是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Broker对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deletewhen=04</span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment"># commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment"># ConsumeQueue每个文件默认存30条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line"><span class="comment"># commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line"><span class="comment"># 消费队列存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line"><span class="comment"># checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment"># Broker的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h4 id="slave1："><a href="#slave1：" class="headerlink" title="slave1："></a>slave1：</h4><p>服务器：192.168.25.138</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment"># broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line"><span class="comment"># 0表示Master，&gt;0表示Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment"># nameServer地址，分号分隔</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment"># 是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Broker对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deletewhen=04</span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment"># commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment"># ConsumeQueue每个文件默认存30条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line"><span class="comment"># commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line"><span class="comment"># 消费队列存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line"><span class="comment"># checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment"># Broker的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h3 id="修改启动脚本文件"><a href="#修改启动脚本文件" class="headerlink" title="修改启动脚本文件"></a>修改启动脚本文件</h3><p><strong>runbroker.sh</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runbroker.sh</span><br></pre></td></tr></table></figure>

<p>需要根据内存大小进行适当的对JVM参数进行调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#===================================</span></span><br><span class="line"><span class="comment"># 开发环境配置 JVM Configuration</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>runserver.sh</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runserver.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p><strong>启动NameServer集群</strong></p>
<p>分别在192.168.25.135和192.168.25.138启动NameServer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rocketmq/bin</span><br><span class="line"><span class="built_in">nohup</span> sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p><strong>启动Broker集群</strong></p>
<p>在192.168.25.135上启动master1和slave2</p>
<p>master1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rocket/bin</span><br><span class="line"><span class="built_in">nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>

<p>slave2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rocket/bin</span><br><span class="line"><span class="built_in">nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>

<p>在192.168.25.138上启动master2和slave1</p>
<p>master2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rocket/bin</span><br><span class="line"><span class="built_in">nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>

<p>slave1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/rocket/bin</span><br><span class="line"><span class="built_in">nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class="built_in">sync</span>/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>

<p>通过<code>jps</code>查看进程状态</p>
<p><strong>查看日志</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nameserver日志</span></span><br><span class="line"><span class="built_in">tail</span> -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="comment"># 查看broler日志</span></span><br><span class="line"><span class="built_in">tail</span> -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<h3 id="mqadmin管理工具"><a href="#mqadmin管理工具" class="headerlink" title="mqadmin管理工具"></a>mqadmin管理工具</h3><p><strong>使用方式</strong></p>
<p>进入RocketMQ目录，在bin目录下执行<code>./mqadmin &#123;command&#125; &#123;args&#125;</code></p>
<h4 id="Topic相关"><a href="#Topic相关" class="headerlink" title="Topic相关"></a>Topic相关</h4><p>&#x3D;&#x3D;updateTopic&#x3D;&#x3D;：创建更新Topic配置</p>
<table>
<thead>
<tr>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>broker地址，表示topic所在broker，只支持单台broker，地址为ip:port</td>
</tr>
<tr>
<td>-c</td>
<td>cluster名称，表示topic所在集群（集群可通过clusterList查询）</td>
</tr>
<tr>
<td>-h-</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式ip:port</td>
</tr>
<tr>
<td>-p</td>
<td>指定新的topic读写权限（W&#x3D;2|R&#x3D;4|WR&#x3D;6）</td>
</tr>
<tr>
<td>-r</td>
<td>可读队列数（默认为8）</td>
</tr>
<tr>
<td>-w</td>
<td>可写队列数（默认为8）</td>
</tr>
<tr>
<td>-t</td>
<td>topic名称（名称只能使用字符^[a-zA-Z0-9_-]+$）</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;deleteTopic&#x3D;&#x3D;：删除Topic</p>
<table>
<thead>
<tr>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>cluster名称，表示删除某集群下的某个topic（集群可通过clusterList查询）</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式ip:port</td>
</tr>
<tr>
<td>-t</td>
<td>topic名称（名称只能使用字符^[a-zA-Z0-9_-]+$）</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;topicList&#x3D;&#x3D;：查看topic列表信息</p>
<table>
<thead>
<tr>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-c</td>
<td>不配置-c只返回topic列表，增加-c返回clusterName，topic，consumerGroup信息，<br />即topic的所属集群和订阅关系，没有参数</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式ip:port</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;topicRouter&#x3D;&#x3D;：查看topic路由信息</p>
<table>
<thead>
<tr>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-t</td>
<td>topic名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式ip:port</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;topicStatus&#x3D;&#x3D;：查看topic消息队列offset</p>
<table>
<thead>
<tr>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-t</td>
<td>topic名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式ip:port</td>
</tr>
</tbody></table>
<p>&#x2F;&#x2F;todo</p>
<h4 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h4><h4 id="Broker相关"><a href="#Broker相关" class="headerlink" title="Broker相关"></a>Broker相关</h4><h4 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h4><h4 id="消费者、消费组相关"><a href="#消费者、消费组相关" class="headerlink" title="消费者、消费组相关"></a>消费者、消费组相关</h4><h4 id="连接相关"><a href="#连接相关" class="headerlink" title="连接相关"></a>连接相关</h4><h4 id="NameServer相关"><a href="#NameServer相关" class="headerlink" title="NameServer相关"></a>NameServer相关</h4><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>几乎所有命令配置都需要配置-n表示NamServer地址，格式为ip:port</p>
</li>
<li><p>几乎所有命令都可以通过-h获取帮助</p>
</li>
<li><p>如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令</p>
</li>
</ul>
<h3 id="集群监控平台搭建"><a href="#集群监控平台搭建" class="headerlink" title="集群监控平台搭建"></a>集群监控平台搭建</h3><p><strong>概述</strong></p>
<p>RocketMQ有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目，先将<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>拉到本地，对<code>rocketmq-console</code>进行编译打包运行。</p>
<p><strong>下载并编译打包</strong></p>
<p>在rocketmq-console的配置文件中配置namesrv集群地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq.config.namesrvAddr</span>=<span class="string">192.168.25.135:9876;192.168.25.138:9876;</span></span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar rocketmq-console.jar</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080</code></p>
<h1 id="消息发送样例"><a href="#消息发送样例" class="headerlink" title="消息发送样例"></a>消息发送样例</h1><ul>
<li><p>导入MQ客户端依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息发送者步骤分析</p>
<ul>
<li>创建消息生产者producer，并制定生产者组名</li>
<li>指定NameServer地址</li>
<li>启动producer</li>
<li>创建消息对象，指定主题topic、tag和消息体</li>
<li>发送消息</li>
<li>关闭生产者producer</li>
</ul>
</li>
<li><p>消息消费者步骤分析</p>
<ul>
<li>创建消费者consumer，并指定消费者组名</li>
<li>指定NameServer地址</li>
<li>订阅主题topic和tag</li>
<li>设置回调函数，处理消息</li>
<li>启动消费者consumer</li>
</ul>
</li>
</ul>
<h2 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h2><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><strong>发送同步消息</strong></p>
<blockquote>
<p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送同步消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化消息生产者producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息，并指定topic、tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;sync&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//发送消息到一个broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            <span class="comment">//通过result返回消息是否成功送达</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送异步消息</strong></p>
<blockquote>
<p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待broker的响应</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送异步消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化消息生产者producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息，并指定topic、tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;async&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//发送异步消息</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">//发送成功的回调函数</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发送结果：&quot;</span>+sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发送失败的回调函数</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发送异常：&quot;</span>+throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送单向消息</strong></p>
<blockquote>
<p>这种方式主要用在不特别关心发送结果的场景，例如日志发送</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送单向消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化消息生产者producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息，并指定topic、tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;oneway&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//发送单向消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><ul>
<li>负载均衡模式——消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同</li>
<li>广播模式——消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建消费者，指定组名</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅主题topic和tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;tag&quot;</span>);</span><br><span class="line">        <span class="comment">//设定消费模式：负载均衡（CLUSTERING） | 广播（BROADCASTING）</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="comment">//设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">//接收消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : list</span><br><span class="line">                     ) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序是指可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue（分区队列）；而消费消息的时候从多个queue上拉去消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则保证了顺序。当发送和消费参与的queue只有一个，则是全局顺序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<blockquote>
<p>下面用订单进行分区有序的实例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p>
</blockquote>
<h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 顺序消息发送者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化消息生产者producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//构建消息集合</span></span><br><span class="line">        List&lt;OrderStep&gt; orderStepList = OrderStep.buildOrders();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (OrderStep order : orderStepList) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;orderTopic&quot;</span>, <span class="string">&quot;order&quot;</span>, order.toString().getBytes());</span><br><span class="line">            <span class="comment">//param1：消息对象</span></span><br><span class="line">            <span class="comment">//param2：消息队列的选择器</span></span><br><span class="line">            <span class="comment">//param3：选择队列的业务标识（订单ID）</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                <span class="comment">//param1：队列集合</span></span><br><span class="line">                <span class="comment">//param2：消息对象</span></span><br><span class="line">                <span class="comment">//param3：业务标识参数</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object arg)</span> &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">long</span>) arg;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> orderId % list.size();</span><br><span class="line">                    <span class="keyword">return</span> list.get((<span class="type">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, order.getOrderId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果：&quot;</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序消息消费"><a href="#顺序消息消费" class="headerlink" title="顺序消息消费"></a>顺序消息消费</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 顺序消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建消费者，指定组名</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅主题topic和tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;orderTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt message : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名称【&quot;</span> + Thread.currentThread() + <span class="string">&quot;】：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><blockquote>
<p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存</p>
</blockquote>
<h3 id="启动消息消费者"><a href="#启动消息消费者" class="headerlink" title="启动消息消费者"></a>启动消息消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 延时消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建消费者，指定组名</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅主题topic和tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;DelayTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt message : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Receive Message[msgId=&quot;</span> + message.getMsgId() + <span class="string">&quot;]&quot;</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">&quot;ms latter&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 延时消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化一个生产者来产生延时消息</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息，并指定topic、tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;DelayTopic&quot;</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello Schedule Message&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//设置延时等级3，这个消息将在10s之后发送（现在只支持固定几个时间，详看delayTimeLevel</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//发送异步消息</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>将会看到消息的消费比存储时间晚10秒</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在RocketMQ不支持任意时间的延迟，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><blockquote>
<p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不能超过4MB。</p>
</blockquote>
<h3 id="发送批量消息"><a href="#发送批量消息" class="headerlink" title="发送批量消息"></a>发送批量消息</h3><p>如果每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">message.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;orderId001&quot;</span>, <span class="string">&quot;HelloWorld 1&quot;</span>.getBytes()));</span><br><span class="line">message.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;orderId002&quot;</span>, <span class="string">&quot;HelloWorld 2&quot;</span>.getBytes()));</span><br><span class="line">message.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;orderId003&quot;</span>, <span class="string">&quot;HelloWorld 3&quot;</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(messages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果消息的总长度大于4MB，最好把消息进行分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 将大消息分裂成若干个小消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span>  <span class="operator">=</span> currIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> message.getTopic().length() + message.getBody().length;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : properties.entrySet())&#123;</span><br><span class="line">                tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加日志的开销20字节</span></span><br><span class="line">            tmpSize  = tmpSize + <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmpSize &gt; SIZE_LIMIT)&#123;</span><br><span class="line">                <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">                <span class="comment">//忽略，否则会阻塞分裂的进程</span></span><br><span class="line">                <span class="keyword">if</span>(nextIndex - currIndex == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//假如下一个字列表没有元素，则添加这个字列表然后退出循环，否则只是退出循环</span></span><br><span class="line">                    nextIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpSize + totalSize &gt; SIZE_LIMIT)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Message&gt; subList = <span class="built_in">this</span>.messages.subList(currIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListSplitter</span>(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasnext())&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">        producer.send(listItem);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><blockquote>
<p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息，SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。</p>
<h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性，也可以很容易扩展它。</p>
<ul>
<li>数值比较，比如：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;；</li>
<li>字符比较，比如：&#x3D;，&lt;&gt;，IN；</li>
<li>IS NULL 或者 IS NOT NULL；</li>
<li>逻辑符号AND，OR，NOT；</li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：123，3.1415；</li>
<li>字符，比如：’abc’，必须用单引号包裹起来；</li>
<li>NULL，特殊的常量；</li>
<li>布尔值，TRUE 或 FALSE；</li>
</ul>
<p>只有使用&#x3D;&#x3D;push&#x3D;&#x3D;模式的消费者才能用使用SQL92标准的SQL语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span><br></pre></td></tr></table></figure>

<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置一些属性</span></span><br><span class="line">message.putUserProperty(<span class="string">&quot;i&quot;</span>, String.valueOf(i));</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;FilterSQLTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i between 0 and 3&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="事务消息发送及提交"><a href="#事务消息发送及提交" class="headerlink" title="事务消息发送及提交"></a>事务消息发送及提交</h3><blockquote>
<p>事务消息的大致方案分为两个流程，正常事务消息的发送及提交、事务消息的补偿流程。</p>
</blockquote>
<h3 id="事务消息发送及提交-1"><a href="#事务消息发送及提交-1" class="headerlink" title="事务消息发送及提交"></a>事务消息发送及提交</h3><ul>
<li>发送消息（half消息）</li>
<li>服务端响应消息写入结果</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）</li>
<li>根据本地事务状态执行commit或者rollback（commit操作生产消息索引，消息对消费不可见）</li>
</ul>
<h3 id="事务补偿"><a href="#事务补偿" class="headerlink" title="事务补偿"></a>事务补偿</h3><ul>
<li>对没有commit&#x2F;rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li>
<li>Producer收到回查消息，检查回查消息对应的本地事务的状态</li>
<li>根据本地事务状态，重新commit或者rollback</li>
</ul>
<p>其中，补偿阶段用于解决消息commit或者rollback发生超时或者失败的情况。</p>
<h3 id="事务消息状态"><a href="#事务消息状态" class="headerlink" title="事务消息状态"></a>事务消息状态</h3><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息</li>
<li>TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费</li>
<li>TransactionStatus.Unknown：中间状态，它代表需要检查消息队列来确定状态</li>
</ul>
<h3 id="发送事务消息"><a href="#发送事务消息" class="headerlink" title="发送事务消息"></a>发送事务消息</h3><p><strong>创建事务性生产者</strong></p>
<blockquote>
<p>使用<code>TransactionMQProducer</code>类创建生产者，并指定唯一的<code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务之后、需要根据执行结果对消息队列进行回复。回传的事务状态参考前一节。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 顺序消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化事务消息生产者producer</span></span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;36.133.171.94:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//添加事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">            <span class="comment">//在该方法中执行本地事务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(StringUtils.equals(<span class="string">&quot;TagA&quot;</span>,message.getTags()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TagB&quot;</span>,message.getTags()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TagC&quot;</span>,message.getTags()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该方法是MQ进行消息事务状态回查</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息的Tag：&quot;</span>+messageExt.getTags());</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息，并指定topic、tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TransactionTopic&quot;</span>,</span><br><span class="line">                    tags[i],</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">//发送消息到一个broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.sendMessageInTransaction(message,<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//通过result返回消息是否成功送达</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不再发送消息，关闭producer实例</span></span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现事务的监听接口</strong></p>
<p>当发送半消息成功时，我们使用<code>executeLocalTransaction</code>方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTransaction</code>方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><ul>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次 而导致半队列消息累积，默认将单个消息的检查次数限制为15次，但是用户可以通过配置Broker的配置文件<code>transactionCheckMax</code>参数来修改此限制，如果已经检查某条消息超过N次的话（N&#x3D;<code>transactionCheckMax</code>），则Broker将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写<code>AbstractTransactionCheckListener</code>类来修改这个行为。</li>
<li>事务消息将在Broker配置文件中的参数<code>transactionMsgTimeout</code>这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置属性<code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>来改变这个限制，该参数优于<code>transactionMsgTimeout</code>参数。</li>
<li>事务消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过RocketMQ本身的高可用性机制来保证，如果希望确保事务不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者ID不能与其他类型消息的生产者ID共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者ID查询到消费者。</li>
</ul>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ高级</title>
    <url>/2022/10/24/RocketMQ%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储</p>
<p><img src="/RocketMQ%E9%AB%98%E7%BA%A7%5Cimage-20221026211951678.png"></p>
<p>1、消息生成者发送消息</p>
<p>2、MQ收到消息，将消息进行持久化，在存储中新增一天记录</p>
<p>3、返回ACK给生产者</p>
<p>4、MQ push消息给对应的消费者，然后等待消费者返回ACK</p>
<p>5、如果消息消费者在指定时间内成功返回ACK，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息，重复执行4、5、6步骤</p>
<p>6、MQ删除消息</p>
<h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><ul>
<li><p>关系型数据库DB</p>
<p>Apache下开源的另一款MQ——ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如MqSQL）在单表数据量打到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障。</p>
</li>
<li><p>文件系统</p>
<p>目前较为常用的几款产品（RocketMQ&#x2F;Kafka&#x2F;RabbitMQ），均采用的是消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
</li>
</ul>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>文件系统 &gt; 关系型数据库DB</p>
<h3 id="消息的存储和发送"><a href="#消息的存储和发送" class="headerlink" title="消息的存储和发送"></a>消息的存储和发送</h3><h4 id="消息存储-1"><a href="#消息存储-1" class="headerlink" title="消息存储"></a>消息存储</h4><p>RocketMQ的消息用顺序写，保证了消息存储的速度</p>
<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。一台服务器把本地磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<p>（1）read：读取本地文件内容</p>
<p>（2）write：将读取的内容通过网络发送出去</p>
<p>这两个看似简单的操作，实际进行了4次数据复制，分别是：</p>
<p>1、从磁盘复制数据到内核态内存；</p>
<p>2、从内核态内存复制到用户态内存；</p>
<p>3、然后从用户态内存复制到网络驱动的内核态内存；</p>
<p>4、最后是从网络驱动的内核态内存复制到网卡中进行传输；</p>
<p><img src="/RocketMQ%E9%AB%98%E7%BA%A7%5Cimage-20221026215719035.png"></p>
<p>通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的，RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p>
<h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每个Topic下的每个MessageQueue都有一个对应的ConsumeQueue文件。</p>
<p><img src="/RocketMQ%E9%AB%98%E7%BA%A7%5Cimage-20221026221117882.png"></p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumeQueue：存储消息在CommitLog的索引</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复，又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时候，有两种写磁盘方式，分别是同步刷盘和异步刷盘。</p>
<p><img src="/RocketMQ%E9%AB%98%E7%BA%A7%5Cimage-20221026223057016.png"></p>
<h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</p>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>通过Broker配置文件里的flushDiskType参数设置的，这个参数被配置成<strong>SYNC_FLUSH</strong>、<strong>ASYNC_FLUSH</strong>中的</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ项目进阶</title>
    <url>/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h1><h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h2><p>模拟电商网站购物场景中的【下单】和【支付】业务</p>
<h3 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h3><img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221011215750789.png" class="">

<ul>
<li>用户请求订单系统下单</li>
<li>订单系统通过RPC调用订单服务下单</li>
<li>订单服务调用优惠券服务，扣减优惠券</li>
<li>订单服务调用库存服务，校验并扣减库存</li>
<li>订单服务调用用户服务，扣减用户余额</li>
<li>订单服务完成确认订单</li>
</ul>
<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221011220228357.png" class="">

<ul>
<li>用户请求支付系统</li>
<li>支付系统调用第三方支付平台API进行发起支付流程</li>
<li>用户通过第三方支付平台支付成功后，第三方支付平台回调通知支付系统</li>
<li>支付系统调用订单服务修改订单状态</li>
<li>支付系统调用积分服务添加积分</li>
<li>支付系统调用日志服务记录日志</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>用户提交订单后，扣减库存成功、扣减优惠券成功、使用余额成功、但是在确认订单操作失败，需要对库存、余额进行回退。如何保证数据完整性？</p>
<p><strong>使用MQ保证在下单失败后系统数据的完整性</strong></p>
<img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221011221449144.png" class="">

<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>用户通过第三方支付平台（支付宝、微信）支付成功后，第三方支付平台要通过回调API异步通知商家支付系统用户支付结果，支付系统根据支付结果修改订单状态、记录支付日志和给用户增加积分。</p>
<p>商家支付系统如何保证在收到第三方支付平台的异步通知时，如何快速给第三方支付凭条做出回应？</p>
<p><strong>使用MQ进行数据分发，提高系统处理性能</strong></p>
<h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>SpringBoot</li>
<li>Dubbo</li>
<li>Zookeeper</li>
<li>RocketMQ</li>
<li>MySql</li>
</ul>
<h2 id="SpringBoot整合RocketMQ"><a href="#SpringBoot整合RocketMQ" class="headerlink" title="SpringBoot整合RocketMQ"></a>SpringBoot整合RocketMQ</h2><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nameserver</span></span><br><span class="line"><span class="attr">rocketmq.name-server</span>=<span class="string">36.133.171.94:9876</span></span><br><span class="line"><span class="comment"># 发送者组名</span></span><br><span class="line"><span class="attr">rocketmq.producer.group</span>=<span class="string">my-group</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消息生产测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;springboot-rocketmq&quot;</span>,<span class="string">&quot;Hello SpringBoot RocketMQ&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><ul>
<li><p>添加依赖</p>
</li>
<li><p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者组名</span></span><br><span class="line"><span class="attr">rocketmq.consumer.group</span>=<span class="string">my-group</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息监听器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消息监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;springboot-rocketmq&quot;, consumerGroup = &quot;$&#123;rocketmq.consumer.group&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot整合Dubbo"><a href="#SpringBoot整合Dubbo" class="headerlink" title="SpringBoot整合Dubbo"></a>SpringBoot整合Dubbo</h2><img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221015212755804.png" class="">

<h3 id="搭建Zookeeper集群"><a href="#搭建Zookeeper集群" class="headerlink" title="搭建Zookeeper集群"></a>搭建Zookeeper集群</h3><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>安装JDK</li>
<li>将Zookeeper上传服务器</li>
<li>解压Zookeeper，并创建data目录，将conf下的zoo_sample.cfg改名为zoo.cfg</li>
<li>建立<code>/usr/local/zookeeper-cluster</code>，将解压后的Zookeeper复制到一下三个目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-1</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置每一个Zookeeper的dataDir（zoo.cfg）clientPort分别为2181、2182、2183</p>
<p>修改每一个zookeeper下的<code>/conf/zoo.cfg</code>文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-1/data</span><br><span class="line"></span><br><span class="line">clientPort=2182</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-2/data</span><br><span class="line"></span><br><span class="line">clientPort=2183</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-3/data</span><br></pre></td></tr></table></figure>

<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><ul>
<li><p>在每一个zookeeper的data目录下创建一个myid文件，内容分别是1、2、3。这个文件就是记录每个服务器的ID</p>
</li>
<li><p>在每一个zookeeper的zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表</p>
<p>集群服务器IP列表如下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quorumListenOnAllIPs=<span class="literal">true</span></span><br><span class="line">server.1=192.168.25.140:2881:3881</span><br><span class="line">server.2=192.168.25.140:2882:3882</span><br><span class="line">server.3=192.168.25.140:2883:3883</span><br></pre></td></tr></table></figure>

<p><code>quorumListenOnAllIPs</code>：当设置为true时，ZooKeeper服务器将在所有可用IP地址上侦听来自其对等方的连接，而不仅是在配置文件的服务器列表中配置的地址。它会影响处理ZAB协议和快速领导者选举协议的连接。默认值为<strong>false</strong>。参考：<a href="https://blog.csdn.net/u014284000/article/details/74508963">https://blog.csdn.net/u014284000/article/details/74508963</a></p>
<p>sever.服务器ID&#x3D;服务器IP地址:服务器之间通信端口:服务器之间投票选举端口</p>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>启动集群就是分别启动每个实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zookeeper-1/bin/zkServer.sh start</span><br><span class="line">./zookeeper-2/bin/zkServer.sh start</span><br><span class="line">./zookeeper-3/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">查看状态</span><br><span class="line">./zookeeper-3/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<h2 id="PRC服务接口"><a href="#PRC服务接口" class="headerlink" title="PRC服务接口"></a>PRC服务接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDubboService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务应用名称</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">provider-server</span></span><br><span class="line"><span class="comment"># 注册中心地址</span></span><br><span class="line"><span class="attr">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">1.13.248.197:2181,1.13.248.197:2182,1.13.248.197:2183</span></span><br><span class="line"><span class="comment"># 哪些服务要被注册</span></span><br><span class="line"><span class="attr">dubbo.scan.base-packages</span>=<span class="string">com.wzzc.service</span></span><br><span class="line"><span class="comment"># 协议默认端口</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure>

<h3 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//使用了dubbo尽量不使用@Service注解</span></span><br><span class="line"><span class="meta">@Service</span>   <span class="comment">//可以被扫描到，在项目已启动j就自动注册到注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IDubboService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者去哪里拿服务，需要暴露自己的名称</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">consumer-server</span></span><br><span class="line"><span class="comment"># 注册中心的地址</span></span><br><span class="line"><span class="attr">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">1.13.248.197:2181,1.13.248.197:2182,1.13.248.197:2183</span></span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用pom坐标；可以定义路径相同的接口名</span></span><br><span class="line">    <span class="comment">//要拿到provider-server提供的服务，要去注册中心拿到服务</span></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IDubboService dubboService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboService.sayHello(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="优惠券表"><a href="#优惠券表" class="headerlink" title="优惠券表"></a>优惠券表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>coupon_id</td>
<td>bigint(50) NOT NULL</td>
<td>优惠券ID</td>
</tr>
<tr>
<td>coupon_price</td>
<td>decimal(10,2) NULL</td>
<td>优惠券金额</td>
</tr>
<tr>
<td>user_id</td>
<td>bigint(50) NULL</td>
<td>用户ID</td>
</tr>
<tr>
<td>order_id</td>
<td>bigint(32) NULL</td>
<td>订单ID</td>
</tr>
<tr>
<td>is_used</td>
<td>int(1) NULL</td>
<td>是否使用，0未使用；1已使用</td>
</tr>
<tr>
<td>used_time</td>
<td>timestamp NULL</td>
<td>使用时间</td>
</tr>
</tbody></table>
<h3 id="商品表"><a href="#商品表" class="headerlink" title="商品表"></a>商品表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>good_id</td>
<td>bigint(50) NOT NULL</td>
<td>商品ID</td>
</tr>
<tr>
<td>good_name</td>
<td>varchar(255) NULL</td>
<td>商品名称</td>
</tr>
<tr>
<td>good_number</td>
<td>int(11) NULL</td>
<td>商品库存</td>
</tr>
<tr>
<td>good_price</td>
<td>decimal(10,2) NULL</td>
<td>商品价格</td>
</tr>
<tr>
<td>good_desc</td>
<td>varchar(255) NULL</td>
<td>商品描述</td>
</tr>
</tbody></table>
<h3 id="订单表"><a href="#订单表" class="headerlink" title="订单表"></a>订单表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>order_id</td>
<td>bigint(50) NOT NULL</td>
<td>订单ID</td>
</tr>
<tr>
<td>user_id</td>
<td>bigint(50) NOT NULL</td>
<td>用户ID</td>
</tr>
<tr>
<td>order_status</td>
<td>int(1) NULL</td>
<td>订单状态，0未确认；1已确认；2已取消；3无效；4退款</td>
</tr>
<tr>
<td>pay_status</td>
<td>int(1) NULL</td>
<td>支付状态，0未支付；1支付中；2已支付</td>
</tr>
<tr>
<td>shipping_status</td>
<td>int(1) NULL</td>
<td>发货状态，0未发货；1已发货；2已退货</td>
</tr>
<tr>
<td>address</td>
<td>varchar(255) NULL</td>
<td>收货地址</td>
</tr>
<tr>
<td>consignee</td>
<td>varchar(255) NULL</td>
<td>收货人</td>
</tr>
<tr>
<td>good_id</td>
<td>bigint(50) NOT NULL</td>
<td>商品ID</td>
</tr>
<tr>
<td>good_number</td>
<td>int(11) NULL</td>
<td>商品数量</td>
</tr>
<tr>
<td>good_price</td>
<td>decimal(10,2) NULL</td>
<td>商品价格</td>
</tr>
<tr>
<td>good_amount</td>
<td>decimal(10,2) NULL</td>
<td>商品总价</td>
</tr>
<tr>
<td>shipping_fee</td>
<td>decimal(10,2) NULL</td>
<td>运费</td>
</tr>
<tr>
<td>order_amount</td>
<td>decimal(10,2) NULL</td>
<td>订单价格</td>
</tr>
<tr>
<td>coupon_id</td>
<td>bigint(50) NOT NULL</td>
<td>优惠券ID</td>
</tr>
<tr>
<td>coupon_paid</td>
<td>decimal(10,2) NULL</td>
<td>优惠券</td>
</tr>
<tr>
<td>money_paid</td>
<td>decimal(10,2) NULL</td>
<td>已付金额</td>
</tr>
<tr>
<td>pay_amount</td>
<td>decimal(10,2) NULL</td>
<td>支付金额</td>
</tr>
<tr>
<td>confirm_time</td>
<td>timestamp NULL</td>
<td>订单确认时间</td>
</tr>
<tr>
<td>pay_time</td>
<td>timestamp NULL</td>
<td>支付时间</td>
</tr>
</tbody></table>
<h3 id="订单商品日志表"><a href="#订单商品日志表" class="headerlink" title="订单商品日志表"></a>订单商品日志表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>good_id</td>
<td>bigint(50) NOT NULL</td>
<td>商品ID</td>
</tr>
<tr>
<td>order_id</td>
<td>bigint(50) NOT NULL</td>
<td>订单ID</td>
</tr>
<tr>
<td>good_number</td>
<td>int(11) NULL</td>
<td>商品库存</td>
</tr>
</tbody></table>
<h3 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>user_id</td>
<td>bigint(50) NOT NULL</td>
<td>用户ID</td>
</tr>
<tr>
<td>username</td>
<td>varchar(255) NOT NULL</td>
<td>用户姓名</td>
</tr>
<tr>
<td>password</td>
<td>varchar(255) NOT NULL</td>
<td>用户密码</td>
</tr>
<tr>
<td>user_mobile</td>
<td>varchar(255) NOT NULL</td>
<td>手机号码</td>
</tr>
<tr>
<td>score</td>
<td>int(11) NULL</td>
<td>积分</td>
</tr>
<tr>
<td>left_money</td>
<td>decimal(10,2) NULL</td>
<td>用户余额</td>
</tr>
</tbody></table>
<h3 id="用户余额日志表"><a href="#用户余额日志表" class="headerlink" title="用户余额日志表"></a>用户余额日志表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>user_id</td>
<td>bigint(50) NOT NULL</td>
<td>用户ID</td>
</tr>
<tr>
<td>order_id</td>
<td>bigint(50) NOT NULL</td>
<td>订单ID</td>
</tr>
<tr>
<td>money_log_type</td>
<td>int(1) NOT NULL</td>
<td>日志类型，1订单付款；2订单退款</td>
</tr>
<tr>
<td>account</td>
<td>decimal(10,2) NULL</td>
<td>操作金额</td>
</tr>
</tbody></table>
<h3 id="订单支付表"><a href="#订单支付表" class="headerlink" title="订单支付表"></a>订单支付表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>pay_id</td>
<td>bigint(50) NOT NULL</td>
<td>支付编号</td>
</tr>
<tr>
<td>order_id</td>
<td>bigint(50) NOT NULL</td>
<td>订单编号</td>
</tr>
<tr>
<td>pay_amount</td>
<td>decimal(10,2) NULL</td>
<td>支付金额</td>
</tr>
<tr>
<td>is_paid</td>
<td>int(1) NULL</td>
<td>是否已支付，0未付款；1正在付款；2已经付款</td>
</tr>
</tbody></table>
<h3 id="MQ消息生产表"><a href="#MQ消息生产表" class="headerlink" title="MQ消息生产表"></a>MQ消息生产表</h3><table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>msg_id</td>
<td>bigint(50) NOT NULL</td>
<td>主键</td>
</tr>
<tr>
<td>group_name</td>
<td>varchar(255) NULL</td>
<td>生产者组名</td>
</tr>
<tr>
<td>msg_topic</td>
<td>varchar(255) NULL</td>
<td>消息主题</td>
</tr>
<tr>
<td>msg_tag</td>
<td>varchar(255) NULL</td>
<td>Tag</td>
</tr>
<tr>
<td>msg_key</td>
<td>varchar(255) NULL</td>
<td>Key</td>
</tr>
<tr>
<td>msg_body</td>
<td>varchar(500) NULL</td>
<td>消息内容</td>
</tr>
<tr>
<td>msg_status</td>
<td>int(1) NULL</td>
<td>0未处理；1已处理</td>
</tr>
</tbody></table>
<h3 id="MQ消息消费表"><a href="#MQ消息消费表" class="headerlink" title="MQ消息消费表"></a>MQ消息消费表</h3><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>msg_id</td>
<td>bigint(50) NOT NULL</td>
<td>消息ID</td>
</tr>
<tr>
<td>group_name</td>
<td>varchar(255) NULL</td>
<td>生产者组名</td>
</tr>
<tr>
<td>msg_topic</td>
<td>varchar(255) NULL</td>
<td>消息主题</td>
</tr>
<tr>
<td>msg_tag</td>
<td>varchar(255) NULL</td>
<td>Tag</td>
</tr>
<tr>
<td>msg_key</td>
<td>varchar(255) NULL</td>
<td>Key</td>
</tr>
<tr>
<td>msg_body</td>
<td>varchar(500) NULL</td>
<td>消息内容</td>
</tr>
<tr>
<td>consumer_status</td>
<td>int(1) NULL</td>
<td>0正在处理；1处理成功；2处理失败</td>
</tr>
<tr>
<td>consumer_times</td>
<td>int(1) NULL</td>
<td>消费次数</td>
</tr>
<tr>
<td>remark</td>
<td>varchar(500) NULL</td>
<td>备注</td>
</tr>
</tbody></table>
<h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><h3 id="工程浏览"><a href="#工程浏览" class="headerlink" title="工程浏览"></a>工程浏览</h3><ul>
<li>父工程：shop</li>
<li>订单系统：order-web</li>
<li>支付系统：pay-web</li>
<li>优惠券服务：coupon-service</li>
<li>订单服务：order-service</li>
<li>支付服务：pay-service</li>
<li>商品服务：good-service</li>
<li>用户服务：user-service</li>
<li>实体类：pojo</li>
<li>持久层：dao</li>
<li>接口层：api</li>
<li>工具工程：common</li>
</ul>
<h3 id="工程关系"><a href="#工程关系" class="headerlink" title="工程关系"></a>工程关系</h3><img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221018202744977.png" class="">

<p><img src="/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6%5Cimage-20221018202853010.png"></p>
<h3 id="Mybatis-Plus代码生成"><a href="#Mybatis-Plus代码生成" class="headerlink" title="Mybatis-Plus代码生成"></a>Mybatis-Plus代码生成</h3><ul>
<li><p>实体类导入pojo中</p>
</li>
<li><p>在服务层工程中导入对应的Mapper类和对应配置文件</p>
</li>
</ul>
<h2 id="公共类介绍"><a href="#公共类介绍" class="headerlink" title="公共类介绍"></a>公共类介绍</h2><ul>
<li><p>ID生成器</p>
<p>IDWorker：Twitter雪花算法</p>
</li>
<li><p>异常处理类</p>
<p>CustomException：自定义异常类</p>
<p>CastException：异常抛出类</p>
</li>
<li><p>常量类</p>
<p>ShopCode：系统状态类</p>
</li>
<li><p>响应实体类</p>
<p>Result：封装响应状态和响应信息</p>
</li>
</ul>
<h1 id="下单业务"><a href="#下单业务" class="headerlink" title="下单业务"></a>下单业务</h1><img src="/2022/10/11/RocketMQ%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6/image-20221018224116237.png" class="">

<h2 id="下单基本流程"><a href="#下单基本流程" class="headerlink" title="下单基本流程"></a>下单基本流程</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Result <span class="title function_">confirmOrder</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务类实现"><a href="#业务类实现" class="headerlink" title="业务类实现"></a>业务类实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderMapper, Order&gt; <span class="keyword">implements</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">confirmOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">//1.校验订单</span></span><br><span class="line">        <span class="comment">//2.生成预订单</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.扣减库存</span></span><br><span class="line">            <span class="comment">//4.扣减优惠券</span></span><br><span class="line">            <span class="comment">//5.使用余额</span></span><br><span class="line">            <span class="comment">//6.确认订单</span></span><br><span class="line">            <span class="comment">//7.返回成功状态</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//1.确认订单失败，发送消息</span></span><br><span class="line">            <span class="comment">//2.返回失败状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="校验订单"><a href="#校验订单" class="headerlink" title="校验订单"></a>校验订单</h3><ul>
<li>订单是否为空</li>
<li>商品是否存在</li>
<li>用户是否存在</li>
<li>订单价格是否合法</li>
<li>购买数量是否合法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验订单是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(order == <span class="literal">null</span>)&#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_ORDER_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.校验订单中的商品是否存在</span></span><br><span class="line">    <span class="type">Good</span> <span class="variable">good</span> <span class="operator">=</span> goodService.findById(order.getGoodId());</span><br><span class="line">    <span class="keyword">if</span>(good == <span class="literal">null</span>)&#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_GOOD_NO_EXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.校验下单用户是否合法</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(order.getUserId());</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_USER_NO_EXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.校验订单金额是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(order.getPayAmount().compareTo(good.getGoodPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(order.getGoodNumber()))) != <span class="number">0</span>)&#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_ORDERAMOUNT_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.校验订单商品数量是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(order.getGoodNumber() &gt; good.getGoodNumber())&#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_GOOD_NUM_NOT_ENOUGH);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;校验订单通过&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成预订单"><a href="#生成预订单" class="headerlink" title="生成预订单"></a>生成预订单</h3><ul>
<li>设置订单状态不可见</li>
<li>设置订单ID</li>
<li>核算运费是否正确</li>
<li>核算订单总价是否正确</li>
<li>是否使用优惠券<ul>
<li>判断优惠券是否合法</li>
</ul>
</li>
<li>是否使用余额<ul>
<li>判断余额是否合法</li>
</ul>
</li>
<li>核算订单总价</li>
<li>设置订单时间</li>
<li>保存订单到数据库</li>
</ul>
<h3 id="扣减库存"><a href="#扣减库存" class="headerlink" title="扣减库存"></a>扣减库存</h3><h3 id="扣减优惠券"><a href="#扣减优惠券" class="headerlink" title="扣减优惠券"></a>扣减优惠券</h3><h3 id="扣减用户余额"><a href="#扣减用户余额" class="headerlink" title="扣减用户余额"></a>扣减用户余额</h3><h3 id="确认订单"><a href="#确认订单" class="headerlink" title="确认订单"></a>确认订单</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h2 id="失败补偿机制"><a href="#失败补偿机制" class="headerlink" title="失败补偿机制"></a>失败补偿机制</h2><h3 id="消息发送方"><a href="#消息发送方" class="headerlink" title="消息发送方"></a>消息发送方</h3><ul>
<li>配置RocketMQ属性值</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq.name-server</span>=<span class="string">36.133.171.94:9876</span></span><br><span class="line"><span class="attr">mq.order.consumer.group.name</span>=<span class="string">order_orderTopic_cancel_group</span></span><br><span class="line"><span class="attr">mq.order.topic</span>=<span class="string">orderTopic</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发生订单确认失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendCancelOrder</span><span class="params">(String topic, String tag, String keys, String body)</span> <span class="keyword">throws</span> MQBrokerException, RemotingException, InterruptedException, MQClientException &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, tag, keys, body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    rocketMQTemplate.getProducer().send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息接收方"><a href="#消息接收方" class="headerlink" title="消息接收方"></a>消息接收方</h3><ul>
<li>配置RocketMQ属性值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rocketmq.name-server=<span class="number">36.133</span><span class="number">.171</span><span class="number">.94</span>:<span class="number">9876</span></span><br><span class="line">mq.order.consumer.group.name=order_orderTopic_cancel_group</span><br><span class="line">mq.order.topic=orderTopic</span><br></pre></td></tr></table></figure>

<ul>
<li>创建监听类，消费消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 订单失败消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;&amp;&#123;mq.order.topic&#125;&quot;, consumerGroup = &quot;$&#123;mq.order.consumer.group.name&#125;&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelMQListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="回退库存"><a href="#回退库存" class="headerlink" title="回退库存"></a>回退库存</h4><ul>
<li>解析消息内容</li>
<li>查询消息消费记录（保证消息处理幂等性）<ul>
<li>处理过<ul>
<li>处理成功</li>
<li>正在处理</li>
<li>处理失败<ul>
<li>判断消息处理次数<ul>
<li>不足3次——数据库乐观锁方式更改消息处理状态为正在处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>未处理<ul>
<li>更改消息状态为正在处理</li>
</ul>
</li>
</ul>
</li>
<li>回退库存</li>
<li>更改消息处理状态为成功</li>
</ul>
<h4 id="回退优惠券"><a href="#回退优惠券" class="headerlink" title="回退优惠券"></a>回退优惠券</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 订单失败消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;&amp;&#123;mq.order.topic&#125;&quot;, consumerGroup = &quot;$&#123;mq.order.consumer.group.name&#125;&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelMQListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponMapper couponMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 解析消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">MQEntity</span> <span class="variable">mqEntity</span> <span class="operator">=</span> JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            log.info(<span class="string">&quot;接收到消息&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(mqEntity.getCouponId() != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//2. 查询优惠券信息</span></span><br><span class="line">                <span class="type">Coupon</span> <span class="variable">coupon</span> <span class="operator">=</span> couponMapper.selectById(mqEntity.getCouponId());</span><br><span class="line">                <span class="comment">//3. 更改优惠券状态</span></span><br><span class="line">                coupon.setUsedTime(<span class="literal">null</span>);</span><br><span class="line">                coupon.setIsUsed(ShopCode.SHOP_COUPON_UNUSED.getCode());</span><br><span class="line">                coupon.setOrderId(<span class="literal">null</span>);</span><br><span class="line">                couponMapper.updateById(coupon);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;回退优惠券成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;回退优惠券失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回退余额"><a href="#回退余额" class="headerlink" title="回退余额"></a>回退余额</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 订单失败取消消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;&amp;&#123;mq.order.topic&#125;&quot;, consumerGroup = &quot;$&#123;mq.order.consumer.group.name&#125;&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelMQListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 解析消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">MQEntity</span> <span class="variable">mqEntity</span> <span class="operator">=</span> JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            log.info(<span class="string">&quot;接收消息成功&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(mqEntity.getUserMoney() != <span class="literal">null</span> &amp;&amp; mqEntity.getUserMoney().compareTo(BigDecimal.ZERO) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//2. 调用业务层，进行余额修改</span></span><br><span class="line">                <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">                userService.updateMoneyPaid(order);</span><br><span class="line">                log.info(<span class="string">&quot;余额回退成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;余额回退成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 订单失败取消消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;&amp;&#123;mq.order.topic&#125;&quot;, consumerGroup = &quot;$&#123;mq.order.consumer.group.name&#125;&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelMQListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 解析消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">MQEntity</span> <span class="variable">mqEntity</span> <span class="operator">=</span> JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            log.info(<span class="string">&quot;接收消息成功&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 查询订单</span></span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(mqEntity.getOrderId());</span><br><span class="line">            <span class="comment">//3. 更新订单状态为取消</span></span><br><span class="line">            order.setOrderStatus(ShopCode.SHOP_ORDER_MESSAGE_STATUS_CANCEL.getCode());</span><br><span class="line">            orderMapper.updateById(order);</span><br><span class="line">            log.info(<span class="string">&quot;订单状态设置为取消&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;订单取消失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h1 id="支付业务"><a href="#支付业务" class="headerlink" title="支付业务"></a>支付业务</h1><h2 id="创建支付订单"><a href="#创建支付订单" class="headerlink" title="创建支付订单"></a>创建支付订单</h2><ul>
<li>判断订单支付状态<ul>
<li>已支付</li>
<li>未支付<ul>
<li>创建支付订单	</li>
<li>设置支付状态为待支付</li>
<li>保存支付订单</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="支付回调"><a href="#支付回调" class="headerlink" title="支付回调"></a>支付回调</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ul>
<li>判断用户支付状态<ul>
<li>支付失败</li>
<li>支付成功<ul>
<li>更细支付订单状态为已支付</li>
<li>创建支付成功消息</li>
<li>保存支付成功消息</li>
<li>发送支付成功消息</li>
<li>删除数据库消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">callbackPayment</span><span class="params">(Pay pay)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;支付回调&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 判断用户支付状态</span></span><br><span class="line">    <span class="keyword">if</span>(pay.getIsPaid().intValue() == ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode().intValue())&#123;</span><br><span class="line">        <span class="comment">//2. 更新支付订单状态为已支付</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">payId</span> <span class="operator">=</span> pay.getPayId();</span><br><span class="line">        <span class="type">Pay</span> <span class="variable">pay1</span> <span class="operator">=</span> payMapper.selectById(payId);</span><br><span class="line">        <span class="comment">//判断支付订单是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(pay1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_PAYMENT_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        pay1.setIsPaid(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> payMapper.updateById(pay1);</span><br><span class="line">        log.info(<span class="string">&quot;支付订单状态改为已支付&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3. 创建支付成功的消息</span></span><br><span class="line">            <span class="type">MqProducerLog</span> <span class="variable">mqProducerLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqProducerLog</span>();</span><br><span class="line">            mqProducerLog.setMsgId(SnowFlakeUtil.getSnowFlakeId());</span><br><span class="line">            mqProducerLog.setGroupName(groupName);</span><br><span class="line">            mqProducerLog.setMsgTopic(topic);</span><br><span class="line">            mqProducerLog.setMsgTag(tag);</span><br><span class="line">            mqProducerLog.setMsgKey(String.valueOf(payId));</span><br><span class="line">            mqProducerLog.setMsgBody(JSON.toJSONString(pay));</span><br><span class="line">            <span class="comment">//4. 将消息持久化数据库</span></span><br><span class="line">            mqProducerLogMapper.insert(mqProducerLog);</span><br><span class="line">            log.info(<span class="string">&quot;将支付成功的消息持久化到数据库&quot;</span>);</span><br><span class="line">            <span class="comment">//5. 发送消息到MQ</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> sendMessage(topic, tag, String.valueOf(payId), JSON.toJSONString(pay));</span><br><span class="line">            <span class="keyword">if</span>(sendResult.getSendStatus().equals(SendStatus.SEND_OK))&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">                <span class="comment">//6. 等待发送结果，如果MQ接收消息，删除发送成功消息</span></span><br><span class="line">                mqProducerLogMapper.deleteById(mqProducerLog.getMsgId());</span><br><span class="line">                log.info(<span class="string">&quot;持久化到数据库的消息删除&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ShopCode.SHOP_SUCCESS.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_PAYMENT_IS_PAID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ShopCode.SHOP_FAIL.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池优化消息发送逻辑"><a href="#线程池优化消息发送逻辑" class="headerlink" title="线程池优化消息发送逻辑"></a>线程池优化消息发送逻辑</h3><ul>
<li>创建线程池对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">getThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    <span class="comment">//默认大小</span></span><br><span class="line">    executor.setCorePoolSize(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//最大线程数</span></span><br><span class="line">    executor.setMaxPoolSize(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;Pool-A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    executor.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程池中进行处理</span></span><br><span class="line">threadPoolTaskExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//5. 发送消息到MQ</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> sendMessage(topic, tag, String.valueOf(payId), JSON.toJSONString(pay));</span><br><span class="line">        <span class="keyword">if</span>(sendResult.getSendStatus().equals(SendStatus.SEND_OK))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            <span class="comment">//6. 等待发送结果，如果MQ接收消息，删除发送成功消息</span></span><br><span class="line">            mqProducerLogMapper.deleteById(mqProducerLog.getMsgId());</span><br><span class="line">            log.info(<span class="string">&quot;持久化到数据库的消息删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h2><p>支付成功后，支付服务payService发送MQ消息，订单服务、用户服务、日志服务需要订阅消息进行处理</p>
<ul>
<li>订单服务修改订单状态为已支付</li>
<li>日志服务记录支付日志</li>
<li>用户服务负责给用户增加积分</li>
</ul>
<p>以下用订单服务为例说明消息的处理情况</p>
<h3 id="配置RocketMQ属性值"><a href="#配置RocketMQ属性值" class="headerlink" title="配置RocketMQ属性值"></a>配置RocketMQ属性值</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mq.pay.topic</span>=<span class="string">payTopic</span></span><br><span class="line"><span class="attr">mq.pay.consumer.group.name</span>=<span class="string">pay_payTopic_group</span></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><ul>
<li>在订单服务中，配置公共的消息处理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 处理消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;$&#123;mq.pay.topic&#125;&quot;, consumerGroup = &quot;$&#123;mq.pay.consumer.group.name&#125;&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 解析消息内容</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">Pay</span> <span class="variable">pay</span> <span class="operator">=</span> JSON.parseObject(body, Pay.class);</span><br><span class="line">            log.info(<span class="string">&quot;接收消息成功&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 根据订单ID查询订单对象</span></span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(pay.getOrderId());</span><br><span class="line">            <span class="comment">//3. 更改订单支付状态为已支付</span></span><br><span class="line">            order.setPayStatus(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">            <span class="comment">//4. 更新订单数据到数据库</span></span><br><span class="line">            orderMapper.updateById(order);</span><br><span class="line">            log.info(<span class="string">&quot;更改订单支付状态为已支付&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>RocketMQ Dubbo Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2022/11/20/Servlet/</url>
    <content><![CDATA[<h1 id="过滤器（Filter）和拦截器（Interceptor）的区别"><a href="#过滤器（Filter）和拦截器（Interceptor）的区别" class="headerlink" title="过滤器（Filter）和拦截器（Interceptor）的区别"></a>过滤器（Filter）和拦截器（Interceptor）的区别</h1><p>都是AOP思想的一种体现，用来解决项目中某一类问题的两种接口（工具），都可以对请求做一些增强。</p>
<table>
<thead>
<tr>
<th></th>
<th>过滤器（Filter）</th>
<th>拦截器（Interceptor）</th>
</tr>
</thead>
<tbody><tr>
<td>出身不同</td>
<td>来自Servlet</td>
<td>来自Spring</td>
</tr>
<tr>
<td>使用范围不同</td>
<td>过滤器Filter实现了javax.servlet.Filter接口，也就是说过滤器的使用要依赖于Tomcat等容易，所以它只能在web程序中使用。</td>
<td>拦截器Interceptor实现了org.springframework.web.Servlet接口，它是由Spring容器进行管理，并不依赖于Tomcat等容器，既可以应用在web程序中，也可以应用在非web程序中（Application，Swing）。</td>
</tr>
<tr>
<td>实现原理不同</td>
<td>基于过滤器链ApplicationFilterChain实现</td>
<td>基于反射</td>
</tr>
<tr>
<td>使用场景不同</td>
<td>字符编码设置、响应数据压缩（通用功能）</td>
<td>是否登录判断、权限判断、日志等等（偏重业务功能）</td>
</tr>
</tbody></table>
<p>触发时机：</p>
<p>Request ———————————————————————&gt;</p>
<p>Tomcat &#x3D;&#x3D;&gt; Filter &#x3D;&#x3D;&gt; Servlet &#x3D;&#x3D;&gt; Interceptor &#x3D;&#x3D;&gt; Controller</p>
<p>&lt;———————————————————————Response</p>
<p>Filter2 doFilter 进入方法前</p>
<p>Filter1 doFilter 进入方法前</p>
<p>Interceptor1 preHandle 前置</p>
<p>Interceptor2 preHandle 前置</p>
<p>Interceptor2 postHandle 处理中</p>
<p>Interceptor1 postHandle 处理中</p>
<p>Interceptor2 afterCompletion 后置</p>
<p>Interceptor1 afterCompletion 后置</p>
<p>Filter1 doFilter Response 响应前</p>
<p>Filter2 doFilter Response 响应前</p>
]]></content>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2022/09/27/Spring/</url>
    <content><![CDATA[<h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><p>在Bean生命周期中，会经历很多对外扩展的方法，可以在这期间做很多额外的操作，整体流程如下：</p>
<ul>
<li>首先是Spring会获取到指定bean的一些原数据信息，也就是&#x3D;&#x3D;BeanDefinition&#x3D;&#x3D;，然后会基于BeanDefinition中的class属性的值，&#x3D;&#x3D;采用反射的方式将对象构建出来&#x3D;&#x3D;，然后基于populateBean方法将对象的一些属性赋值。后续就会经历一些相关的Aware接口，Aware特别多，&#x3D;&#x3D;一般使用ApplicationContextAware的方式，可以用它获取到ApplicationContext对象&#x3D;&#x3D;，从而实现在非Spring容器管理的对象中拿到Spring容器管理的对象；其次，还会经历BeanPostProcessor的前置处理，这里可以动态的去替换bean对象本身。AOP就是借助BeanPostProcessor去构建了代理对象，之后会再经历一个叫做InitializingBean的类中的一个方法：afterPropertiesSet。再往后，就是init-method了，它会执行指定好的初始化方法，最后会执行BeanPostProcessor的后置处理，这样整个对象就构建完毕了，可以正常使用。最后，在工厂销毁之后，单例对象同时也会被销毁，这个时候，就会执行destroy-method以及DisposableBean中的销毁方法。</li>
</ul>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>两个或多个Bean互相之间持有对方的引用，就会发生循环依赖，将会导致注入死循环，这是Spring发生循环依赖的原因。</p>
<p>循环依赖有三种形态：</p>
<ul>
<li>互相依赖</li>
<li>三者间依赖</li>
<li>自我依赖</li>
</ul>
<p>Spring中设计了三级缓存来解决循环依赖问题，&#x3D;&#x3D;当我们去调用<code>getBean()</code>方法的时候，Spring会从一级缓存中去找到目标Bean，&#x3D;&#x3D;如果发现&#x3D;&#x3D;一级缓存中没有变会去二级缓存中找，&#x3D;&#x3D;而如果&#x3D;&#x3D;一、二级缓存中都没有找到，意味着该目标Bean还没有实例化。&#x3D;&#x3D;于是，Spring容器会实例化目标Bean（PS：刚初始化的Bean成为早期Bean）。然后，将目标放入到二级缓存中，同时，加上标记是否存在循环依赖。如果&#x3D;&#x3D;不存在循环依赖便将目标Bean存入到二级缓存，否则，便会标记该Bean存在循环依赖，然后等待下一次轮询赋值，也就是解析@Autowired注解。&#x3D;&#x3D;等@Autowird注解赋值完成后，会将目标Bean存入到一级缓存。</p>
<p><strong>Spring一级缓存中存放所有的成熟Bean，二级缓存中存放所有的早期Bean，先取一级缓存，再取二级缓存。</strong></p>
<p>三级缓存是用来存储代理Bean，当调用getBean()方法时，&#x3D;&#x3D;发现目标Bean需要通过代理工厂来创建。&#x3D;&#x3D;此时会将创建好的实例保存到三级缓存，最终也会将赋值好的Bean同步到一级缓存中。</p>
<p>Spring哪些情况下不能解决循环依赖问题：</p>
<ul>
<li>多例Bean通过setter注入的情况</li>
<li>构造器注入的Bean的情况</li>
<li>单例的代理Bean通过setter注入的情况</li>
<li>设置了@DependsOn的Bean的情况</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/07/29/SpringBoot/</url>
    <content><![CDATA[<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><hr>
<h4 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h4><ul>
<li><p>开发人员仅需规定应用中不符合约定的部分</p>
</li>
<li><p>在没有规定配置的地方，采用默认配置，以力求最简配置为核心思想总的来说，上面两条都遵循了推荐默认配置的思想。当存在特殊需求的时候，自定义配置即可。这样可以大大的减少配置工作，这就是所谓的“约定”。</p>
</li>
</ul>
<h4 id="自动装配-1"><a href="#自动装配-1" class="headerlink" title="自动装配"></a>自动装配</h4><blockquote>
<p><strong>精髓</strong></p>
</blockquote>
<ul>
<li>SpringBoot启动会加载大量 的自动配置类</li>
<li>要写一个自动配置类，看需要的功能有没有在SpringBoot默认写好的自动配置类当中</li>
<li>看自动配置类中配置了哪些组件；（只要要用的组件存在其中，就不需要再手动配置了）</li>
<li>给容器中自动配置类添加组件的时候，会从Properties类中获取某些属性。只需要在配置文件中指定这些属性的值即可<ul>
<li>@XXXAutoConfiguration：自动配置类；给容器中添加组件</li>
<li>@XXXProperties：封装配置文件中相关属性——&gt;yml配置</li>
<li>可以通过debug&#x3D;true来查看，哪些自动配置类生效，哪些没有生效</li>
</ul>
</li>
</ul>
<blockquote>
<p>pom.xml</p>
</blockquote>
<ul>
<li>spring-boot-dependencies：核心依赖在父工程中！</li>
<li>在引入一些SpringBoot依赖的时候，不需要指定版本，因为有这些版本仓库</li>
</ul>
<p>启动器：就是SpringBoot的启动场景。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>比如<code>spring-boot-starte-web</code>，会帮我们自动导入web环境的所有依赖；</p>
</li>
<li><p>SpringBoot会将所有的功能场景，都变成一个个启动器；</p>
</li>
<li><p>如果要使用什么功能，就只需要知道对应的启动器<code>stater</code></p>
</li>
</ul>
<blockquote>
<p>主程序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注这个类是一个SpringBoot的应用：启动类下的所有资源被导入</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//将SpringBoot应用启动</span></span><br><span class="line">        SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span>	<span class="comment">//SpringBoot的配置</span></span><br><span class="line">	<span class="meta">@Configuration</span>	<span class="comment">//Spring配置类</span></span><br><span class="line">		<span class="meta">@Component</span>	<span class="comment">//说明这也是Spring的一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>	<span class="comment">//自动配置</span></span><br><span class="line">	<span class="meta">@AutoConfigurationPackage</span>	<span class="comment">//自动配置包</span></span><br><span class="line">		<span class="meta">@Import(&#123;Registrar.class&#125;)</span>	<span class="comment">//自动配置`包注册`</span></span><br><span class="line">	<span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>	<span class="comment">//自动配置导入选择</span></span><br><span class="line"><span class="meta">@ComponentScan</span>	<span class="comment">//扫描当前主启动类同级的包</span></span><br></pre></td></tr></table></figure>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul>
<li>获得自动配置的实体：</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918233054555.png"></p>
<ul>
<li>获取候选的配置：</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918233340610.png"></p>
<ul>
<li>获取所有加载的配置：</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918235151191.png"></p>
<ul>
<li>标注了@EnableAutoConfiguration注解的类：</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918235326264.png"></p>
<ul>
<li><code>META-INF/spring.factories</code>	自动配置的核心文件</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918230107942.png"></p>
<ul>
<li>所有的资源加载到配置类中，从资源中遍历了所有的nextElement（自动配置），遍历完成之后，封装为一个Properties供使用。</li>
</ul>
<p><img src="/SpringBoot%5Cimage-20220918230640304.png"></p>
<blockquote>
<p>spring.factories中导入了许多自动配置，为什么没有生效，需要导入对应的start才能使用！</p>
</blockquote>
<ul>
<li>@ConditionalOnXXX：如果这里面的条件都满足，才会生效</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>SpringBoot所有的自动配置都是在启动的时候扫描并加载：所有的自动配置类都在<code>spring.factories</code>中，但是不一定生效，要判断条件是否成立，只要导入对应的start，就有了对应的启动器，有了启动器，自动装配就会生效，最后配置成功~</p>
<ul>
<li>SpringBoot在启动的时候，从类路径下<code>/META-INF/spring.factories</code>获取指定的值；</li>
<li>将这些自动配置的类导入容器，自动配置就会生效，帮我们自动进行配置；</li>
<li>以前需要配置的东西，SpringBoot帮我们做了；</li>
<li>整合javaEE，解决方案和自动配置的东西 都在<code>spring-boot-autoconfigure-2.2.0.RELEASE.jar</code>这个包下；</li>
<li>它会把所有需要导入的组件，以全类名的方式返回，这些组件就会被添加到容器中；</li>
<li>容器中存在很多的XXAutoConfiguration的文件（@Bean），就是这些类给容器中导入了这个场景需要的所有组件，并自动配置，@Configuration，JavaConfig；</li>
<li>有了自动配置类，免去了手动编写配置文件的工作~</li>
</ul>
<h4 id="注解分析"><a href="#注解分析" class="headerlink" title="注解分析"></a>注解分析</h4><ul>
<li><p>@Configuration	&#x2F;&#x2F;表明这是一个配置类</p>
</li>
<li><p>@EnableConfigurationProperties    &#x2F;&#x2F;自动配置属性：yml</p>
<ul>
<li>@XXXAutoConfiguration：默认值	@XXXProperties和配置文件绑定，就可以使用自定义的配置</li>
</ul>
</li>
<li><p>@ConditionOnXXX    &#x2F;&#x2F;Spring底层注解：根据不同的条件，来判断当前配置或者类是否生效</p>
<p><img src="/SpringBoot%5Cimage-20220921213320875.png"></p>
</li>
</ul>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><hr>
<h4 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><blockquote>
<p>主要做了四件事</p>
</blockquote>
<ul>
<li>推断应用类型是普通的项目还是Web项目</li>
<li>查找并加载所有可用初始化器，设置到 <strong>initializers</strong> 属性中</li>
<li>找出所有的应用程序监听器，设置到 <strong>listeners</strong> 属性中</li>
<li>推断并设置main方法的定义类，找到运行的主类</li>
</ul>
<h3 id="配置文件yml"><a href="#配置文件yml" class="headerlink" title="配置文件yml"></a>配置文件yml</h3><hr>
<p><strong>生效优先级</strong></p>
<ul>
<li>file：.&#x2F;config&#x2F;</li>
<li>file：.&#x2F;</li>
<li>classpath：&#x2F;config&#x2F;</li>
<li>classpath：&#x2F;</li>
</ul>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud&amp;Alibaba</title>
    <url>/2022/12/14/SpringCloud/</url>
    <content><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><table>
<thead>
<tr>
<th>服务注册与发现</th>
<th>服务负载与调用</th>
<th>服务熔断降级</th>
<th>服务网关</th>
<th>服务配置</th>
<th>服务总线</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td><strong>Ribbon</strong></td>
<td>Hystrix</td>
<td>Zuul</td>
<td>Config</td>
<td>Bus</td>
</tr>
<tr>
<td>Zookeeper</td>
<td><strong>LoadBalancer</strong></td>
<td><strong>Resilience4j</strong></td>
<td><strong>Gateway</strong></td>
<td><strong>Nacos</strong></td>
<td><strong>Nacos</strong></td>
</tr>
<tr>
<td>Consul</td>
<td>Feign</td>
<td><strong>Sentinel</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Nacos</strong></td>
<td><strong>OpenFeign</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p><strong>自我保护机制：</strong>默认情况下EurekaClient定时向EurekaServer端发送心跳包，如果Eureka在server端一定时间内（默认90秒）没有收到EurekaClient发送的心跳包，便会直接从服务注册列表中剔除该服务，但是在短时间（90秒中）内丢失了大量的服务实例心跳，这时候EurekaServer会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通，但是EurekaClient未出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的）。</p>
<p>&#x3D;&#x3D;在自我保护模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例。&#x3D;&#x3D;</p>
<p><strong>属于CAP里面AP分支</strong></p>
<h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><p><a href="http://www.consul.io/intro/index.html">http://www.consul.io/intro/index.html</a></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>语言</th>
<th>CAP</th>
<th>服务健康检查</th>
<th>对外暴露接口</th>
<th>Spring Cloud集成</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP</td>
<td>可配支持</td>
<td>HTTP</td>
<td>已集成</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>可支持</td>
<td>HTTP&#x2F;DNS</td>
<td>已集成</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>可支持</td>
<td>客户端</td>
<td>已集成</td>
</tr>
<tr>
<td>Nacos</td>
<td></td>
<td>AP</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>C：Consistency（强一致性）</li>
<li>A：Availability（可用性）</li>
<li>P：Partition tolerance（分区容错性）</li>
</ul>
<p>CAP理论核心：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</strong>，因此分成三大类：</p>
<ul>
<li>CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大</li>
<li>CP：满足一致性，分区容忍性的系统，通常性能不是特别高</li>
<li>AP：满足可用性，分区容忍性的系统，通常可能对一致性要求低一些</li>
</ul>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><p>NetFlix开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和调用。</strong>提供一系列完善的配置项如连接超时，重试等。</p>
<p>Ribbon本地负载均衡客户端与Nginx服务端负载均衡区别：</p>
<p>Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后有Nginx实现转发请求。即负载均衡是由服务端实现的。</p>
<p>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现PRC远程服务调用技术。</p>
<p><strong>集中式LB：</strong>即在服务消费方与提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方；</p>
<p><strong>进程内LB：</strong>将LB逻辑集成到消费方，消费方从服务注册中心获取有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>
<p>&#x3D;&#x3D;Ribbon就属于进程内LB&#x3D;&#x3D;，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><blockquote>
<p>Feign是一个声明式的Web服务客户端，让编写Web服务器客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可。旨在使编写Java Http客户端变得更容易</p>
</blockquote>
<p>在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>OpenFeign默认等待1秒钟，超过后报错，&#x3D;&#x3D;默认支持Ribbon&#x3D;&#x3D;，开启客户端超时控制：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置Feign客户端超时时间</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#  指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#  指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnetTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h2 id="日志增强"><a href="#日志增强" class="headerlink" title="日志增强"></a>日志增强</h2><p>Feign提供了日志打印功能，可以通过配置来调整日志级别，从而了解Feign中Http请求的细节，&#x3D;&#x3D;Feign接口的调用情况进行监控和输出&#x3D;&#x3D;。</p>
<p>日志级别：</p>
<ul>
<li>NONE：默认的，不显示任何日志；</li>
<li>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li>
<li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息；</li>
<li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ul>
<p>配置日志Bean；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>YML文件里开启日志的Feign客户端</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.wzzc.order.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>



<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），<strong>向调用方向返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback。</p>
<p>哪些情况会触发降级：</p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池&#x2F;信号量打满也会导致服务降级</li>
</ul>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示；</p>
<p>就是保险丝，服务降级——&gt;进而熔断——&gt;恢复调用链路</p>
<h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。</p>
<h2 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h2><img src="/2022/12/14/SpringCloud/image-20230211173828755.png" class="">

<p><strong>并发故障现象及原因：</strong>8001同一层次的其他接口服务被困死，因为Tomcat线程池里面的工作线程已经被挤占完毕</p>
<p>80此时调用8001，客户端访问响应慢，转圈圈。</p>
<p><strong>问题：</strong></p>
<ul>
<li>超时导致服务器变慢（转圈）——超时不再等待</li>
<li>出错（宕机或程序运行出错）——出错要有兜底</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li>对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级</li>
<li>对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级</li>
<li>对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己等待的时间小于服务提供者），自己处理降级</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="服务降级-HystrixCommand"><a href="#服务降级-HystrixCommand" class="headerlink" title="服务降级@HystrixCommand"></a>服务降级<code>@HystrixCommand</code></h3><blockquote>
<p><strong>提供者：</strong>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback</p>
</blockquote>
<p>业务类启用——<code>@HystrixCommand</code>报异常后如何处理</p>
<ul>
<li>一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(time);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_TimeOut，id=&quot;</span> + id + <span class="string">&quot;\t耗时（秒）：&quot;</span> + time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;启动fallback方法：paymentInfo_TimeOut，id=&quot;</span> + id + <span class="string">&quot;\t耗时（秒）：&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主启动类激活——<code>@EnableCircuitBreaker</code></li>
</ul>
<p>当前服务不可用了，做服务降级，兜底的方案都是<code>paymentInfo_TimeOutHandler</code></p>
<blockquote>
<p><strong>消费者：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;80系统繁忙或运行报错，请稍后再试，id=&quot;</span> + id + <span class="string">&quot;\t耗时（秒）：&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局服务降级<code>@DefaultProperties(defaultFallback=&quot;&quot;)</code></p>
</blockquote>
<p>N个除了个别重要核心业务有专属，其他普通的可以通过<code>@DefaultProperties(defaultFallback=&quot;&quot;)</code>统一跳转到统一结果处理页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;globalFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****result：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局fallback方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">globalFallback</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通配服务降级FeignFallback</p>
</blockquote>
<p>为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;provider-hystrix-payment&quot;, fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentHystrixService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p>
<h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当链路的某个微服务出错不可用或者响应时间太长，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。</p>
<p><strong>当监测到该节点微服务调用响应正常后，恢复调用链路。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuiBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),//是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;),//时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;),//失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuiBreaker</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id不能为负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号：&quot;</span> + uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuiBreaker_fallback</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id不能为负数，请稍后再试。id：&quot;</span> + id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>类型：</p>
<ul>
<li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR，（平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态</li>
<li>熔断关闭：不会对服务进行熔断</li>
<li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</li>
</ul>
<p><strong>断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值</strong></p>
<p>断路器开启或关闭条件：</p>
<ol>
<li><p>当满足一定阀值的时候（默认10秒内超过20个请求次数）</p>
</li>
<li><p>当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>
</li>
<li><p>到达以上阀值，断路器将会开启</p>
</li>
<li><p>当开启的时候，所有请求都不会进行转发</p>
</li>
<li><p>一段时间之后（默认5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器关闭，若失败，继续开启；重复4和5</p>
</li>
</ol>
<p>打开之后：</p>
<p>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p>
<p>原来的主逻辑如何恢复：</p>
<p>当断路器打开后，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑。当休眠时间窗到期，断路器进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p>
<h3 id="服务限流-1"><a href="#服务限流-1" class="headerlink" title="服务限流"></a>服务限流</h3><p>看alibaba的Sentinel</p>
<h2 id="HystrixDashboard"><a href="#HystrixDashboard" class="headerlink" title="HystrixDashboard"></a>HystrixDashboard</h2><p>所有Provider微服务提供类（8001&#x2F;8002&#x2F;8003）都需要监控依赖配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- actuator监控信息完善 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径</strong></p>
<p>Unable to connect to Command Metric Stream.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 此配置是为了服务监控的配置，与服务容错本身无关，SpringCloud升级后的坑</span></span><br><span class="line"><span class="comment">  * ServletRegistrationBean因Springboot的默认路径不是”/hystrix.stream“，</span></span><br><span class="line"><span class="comment">  * 只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">hystrixMetricsStreamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(hystrixMetricsStreamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/12/14/SpringCloud/image-20230213222811283.png" class="">



<h1 id="Gateway-amp-amp-Zuul"><a href="#Gateway-amp-amp-Zuul" class="headerlink" title="Gateway&amp;&amp;Zuul"></a>Gateway&amp;&amp;Zuul</h1><blockquote>
<p>使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架</p>
</blockquote>
<p>SpringCloud Gateway目标提供统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如：安全，监控&#x2F;指标、限流。</p>
<ul>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
</ul>
<p>Zuul 1.X是<strong>基于阻塞I&#x2F;O的API Gateway；基于servlet之上的一个阻塞式处理模型</strong>，不支持任何长连接（如WebSocket），设计模式和Nginx比较像，每次I&#x2F;O操作都是从工作线程中选择执行，请求线程被阻塞到工作线程完成。即spring实现了处理所有request请求的一个servlet（DispatcherServlet），并由该servlet阻塞式处理。所以无法摆脱servlet模型的弊端</p>
<p>SpringCloud Gateway建立在Spring FrameWork 5、Project Reactor 和Spring Boot 2之上，使用非阻塞API；还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验。<strong>异步非阻塞</strong></p>
<p>Spring WebFlux是一个典型非阻塞异步的框架，核心是基于Reactor相关API实现的，非阻塞式+函数式是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全<strong>异步非阻塞</strong>的，并且是基于Reactor来实现响应式流规范。</p>
<h2 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h2><ul>
<li>Route（路由）：构建网关的基本模块，由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</li>
<li>Predicate（断言）：可以匹配HTTP请求中的所有内容（例如请求头和请求参数），如果请求与断言相匹配则进行路由</li>
<li>Filter（过滤）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或之后对请求进行修改</li>
</ul>
<p>总体：web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。</p>
<p>predicate就是匹配条件；而filter，就可以理解为拦截器。有了这两个元素，再加上uri，就可以实现一个具体的路由了 。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><img src="/2022/12/14/SpringCloud/image-20230215222740124.png" class="">

<p>客户端向SpringCloud Gateway发出请求。然后在<strong>Gateway Handler Mapping</strong>中找到与请求相匹配的路由，将其发送到<strong>Gateway Web Handler</strong>；</p>
<p><strong>Handler</strong>再通过指定的过滤器来将请求发送到我们实际的服务执行业务逻辑，然后返回；</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。</p>
<p><strong>Filter</strong>在”pre“类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，</p>
<p>在“post”类型的过滤器中可以做响应内容、响应头的修改、日志的输出、流量的监控等有着非常重要的作用。</p>
<p><strong>路由转发</strong> + <strong>执行过滤器链</strong></p>
<h2 id="路由配置两种方式"><a href="#路由配置两种方式" class="headerlink" title="路由配置两种方式"></a>路由配置两种方式</h2><ul>
<li>在配置文件yml中配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span>             <span class="comment">#路由的Id，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>    <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>      <span class="comment">#断言，路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码中注入RouteLocator的Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span>&#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_wzzc&quot;</span>, r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>).uri(<span class="string">&quot;https://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><blockquote>
<p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心 上微服务名为路劲创建动态路由进行转发，从而实现动态路由的功能</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: <span class="literal">true</span> # 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh             #路由的Id，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: lb:<span class="comment">//PROVIDER-PAYMENT    #匹配后提供服务的路由地址</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get<span class="comment">/**      #断言，路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure>

<p><strong>uri的协议为lb，表示启用Gateway的负载均衡功能，lb:&#x2F;&#x2F;serviceName是SpringCloud Gateway在微服务中自动为我们创建的负载均衡uri</strong></p>
<h2 id="常用Predicate"><a href="#常用Predicate" class="headerlink" title="常用Predicate"></a>常用Predicate</h2><blockquote>
<p>匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>       <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">After=2023-02-20T22:50:08.213+08:00[Asia/Shanghai]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cookie=username,wzc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span>  <span class="comment">#请求头要有X-Request-Id属性，并且值为整数的正则表达式、</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Host=**.atguigu.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Method=GET</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Query=username,</span> <span class="string">\d+</span>   <span class="comment">#要有参数username并且还要是整数才能路由</span></span><br></pre></td></tr></table></figure>

<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><blockquote>
<p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</p>
</blockquote>
<p>可用于修改进入HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用</p>
<p>SpringCloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生</p>
<p>生命周期</p>
<ul>
<li>pre</li>
<li>post</li>
</ul>
<p>种类</p>
<ul>
<li>GatewayFilter</li>
<li>GlobalFilter</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestParameter=X-Request-Id,1024</span> <span class="comment">#过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id，值为1024</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>实现GlobalFilter, Ordered两个接口</p>
<p>功能：全局日志记录、统一网关鉴权、。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;===============进入全局过滤器&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="literal">null</span>)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户名为null，非法用户！&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Config-amp-amp-Bus"><a href="#Config-amp-amp-Bus" class="headerlink" title="Config&amp;&amp;Bus"></a>Config&amp;&amp;Bus</h1><p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同的微服务应用的所有环境提供了一个中心化的外部配置。</p>
<ul>
<li>服务端：&#x3D;&#x3D;称为分布式配置中心，是一个独立的微服务应用&#x3D;&#x3D;，用来连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口</li>
<li>客户端：通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器，默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如dev&#x2F;test&#x2F;prod&#x2F;&#x2F;beta&#x2F;release</li>
<li>运行期间动态调整配置，不再需要在每个服务器部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生改变时，服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露，post、curl访问刷新均可……</li>
</ul>
<p>默认使用Git来存储配置文件（也有其他方式，比如支持SVN和本地文件），但推荐的还是Git，而且使用的是http&#x2F;https访问的形式</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>bootstrap.yml 是系统级的，&#x3D;&#x3D;优先级更高&#x3D;&#x3D;</p>
<p>application.yml 是用户级的资源配置项</p>
<p>SpringCloud会创建一个“BootStrap Context”，作为Spring应用的“Application Context”的父上下文。初始化的时候，“BootStrap Context”负责从&#x3D;&#x3D;外部源&#x3D;&#x3D;</p>
<p>加载配置属性并解析配置。这两个上下文共享一个从外部获取的“Environment”。</p>
<p>“BootStrap”属性有高优先级，默认情况下，它们不会被本地配置覆盖。“BootStrap context”和“Application context”有着不同的约定，所以新增了一个“bootstrap.yml”文件，保证“BootStrap context”和“Application context”配置的分离。</p>
<p>&#x3D;&#x3D;要将Client模块下的application.yml文件修改为bootstrap.yml，这很关键。&#x3D;&#x3D;</p>
<p>因为bootstrap.yml是比application.yml先加载的，bootstrap.yml优先级高于application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment"># 分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment"># 读取后缀名称，综合：master分支上config-dev.yml的配置文件被读取 http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment"># 配置中心地址</span></span><br><span class="line"><span class="comment"># 服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<h2 id="分布式配置的动态刷新"><a href="#分布式配置的动态刷新" class="headerlink" title="分布式配置的动态刷新"></a>分布式配置的动态刷新</h2><p>修改Gitee上的配置文件，刷新3344，ConfigServer配置中心立刻响应。</p>
<ul>
<li><p>pom引入actuator监控</p>
</li>
<li><p>修改yml，暴露监控端口</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@RefreshScope业务类Controller修改</p>
</li>
<li><p>发送POST请求刷新3355</p>
<ul>
<li>curl -x POST “<a href="http://localhost:3355/actuator/refresh&quot;">http://localhost:3355/actuator/refresh&quot;</a></li>
</ul>
</li>
</ul>
<h3 id="Bus-Config"><a href="#Bus-Config" class="headerlink" title="Bus+Config"></a>Bus+Config</h3><p>是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。</p>
<p>Bus支持两种消息代理：RabbitMQ，Kafka。</p>
<p>SpringCloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当做微服务间的通信通道。</p>
<p><strong>什么是总线：</strong></p>
<p>在微服务架构的系统中，通常会使用&#x3D;&#x3D;轻量级的消息代理&#x3D;&#x3D;来构建一个&#x3D;&#x3D;共用的消息主题&#x3D;&#x3D;，并让系统中所有微服务实例都连接上来。由于&#x3D;&#x3D;该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。</p>
<p><strong>基本原理：</strong></p>
<p>ConfigClient实例都监听MQ中同一个topic（默认是springCloudBus）。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置。</p>
<h3 id="RabbitMQ消息环境配置"><a href="#RabbitMQ消息环境配置" class="headerlink" title="RabbitMQ消息环境配置"></a>RabbitMQ消息环境配置</h3><ul>
<li>安装Erlang，下载地址：<a href="http://erlang.org/download/">http://erlang.org/download/</a></li>
<li>安装RabbitMQ</li>
<li>进入sbin目录，输入：rabbitmq-plugins enable rabbitmq_management，添加可视化插件；启动MQ，输入<a href="http://127.0.0.1:15672/%E5%B0%B1%E5%8F%AF%E8%AE%BF%E9%97%AE%E4%BA%86%E3%80%82">http://127.0.0.1:15672/就可访问了。</a></li>
</ul>
<p><strong>设计思想：利用消息总线触发一个客户端&#x2F;bus&#x2F;refresh，而刷新所有客户端的配置</strong></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>3344配置中心服务端添加消息总线支持</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">添加消息总线RabbitMQ支持</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rabbitmq相关配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"><span class="comment"># rabbitmq相关配置，暴露bus刷新配置的断电</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3355客户端添加消息总线支持</p>
</li>
<li><p>3366客户端添加消息总线支持</p>
</li>
</ol>
<p>测试：发送post请求：curl -X POST <a href="http://localhost:3344/actuator/bus-refresh">http://localhost:3344/actuator/bus-refresh</a></p>
<h3 id="定点通知"><a href="#定点通知" class="headerlink" title="定点通知"></a>定点通知</h3><p>指定某一个实例生效而不是全部</p>
<p>公式：<a href="http://localhost:3344/actuator/bus-refresh/%7Bdestination%7D">http://localhost:3344/actuator/bus-refresh/{destination}</a></p>
<p>&#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server，通过destination参数类指定需要更新配置的服务或实例</p>
<p>只通知3355：<a href="http://localhost:3344/actuator/bus-refresh/config-client:3355">http://localhost:3344/actuator/bus-refresh/config-client:3355</a></p>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>注册中心+配置中心，Nacos &#x3D; Eureka + Config +Bus</p>
<img src="/2022/12/14/SpringCloud/image-20230308212329947.png" class="" title="image-20230308212329947">

<p><strong>Nacos支持AP和CP模式的切换</strong></p>
<p>C是所有节点在同一时间看到的数据是一致的，而A的定义是所有的请求都会收到响应</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos服务注册中心地址</span></span><br></pre></td></tr></table></figure>

<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p><strong>基础配置</strong></p>
<p>通过SpringCloud原生注解@RefreshScope实现配置自动更新</p>
<p>Nacos的匹配规则</p>
<p>DataId：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-exetension}</p>
<p>prefix默认为spring.application.name的值</p>
<p>spring.profile.active即为当前环境对应的profile，可以通过配置项spring.profile.active来配置</p>
<p>file-extension为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置</p>
<p><strong>分类配置</strong></p>
<p>三种方案加载配置：</p>
<ul>
<li>DataID方案<ul>
<li>指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置</li>
<li>默认空间+默认分组+新建dev和test两个DataID</li>
<li>通过spring.profile.active属性就能进行多环境下配置文件的读取</li>
</ul>
</li>
<li>Group方案<ul>
<li>通过Group实现环境区分</li>
<li>在config下增加一条group的配置即可</li>
</ul>
</li>
<li>Namespace方案<ul>
<li>新建dev&#x2F;test的Namespace</li>
<li>新增namespace配置</li>
</ul>
</li>
</ul>
<h2 id="集群和持久化配置"><a href="#集群和持久化配置" class="headerlink" title="集群和持久化配置"></a>集群和持久化配置</h2><p>nginx配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gzip  on;</span></span><br><span class="line">upstream cluster&#123;</span><br><span class="line">    server 127.0.0.1:8847;</span><br><span class="line">    server 127.0.0.1:8848;</span><br><span class="line">    server 127.0.0.1:8849;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    #root   html;</span><br><span class="line">    #index  index.html index.htm;</span><br><span class="line">    proxy_pass http://cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>采用懒加载，执行一次访问即可</p>
<h2 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h2><ul>
<li>资源名：唯一名称，默认请求路径</li>
<li>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认Default（不区分来源）</li>
<li>阈值类型&#x2F;单机阈值<ul>
<li>QPS（每秒钟的请求数量）：当调用该api的QPS达到阈值的时候，进行限流。</li>
<li>线程数：当调用该api的线程数达到阈值的时候，进行限流</li>
</ul>
</li>
<li>是否集群：不需要集群</li>
<li>流控模式：<ul>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己<ul>
<li>当与A关联的资源B达到阈值后，就限流A自己</li>
</ul>
</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】</li>
</ul>
</li>
<li>流控效果：<ul>
<li>快速失败：直接失败，抛异常</li>
<li>Warm Up：根据codeFactor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设定的QPS阈值</li>
<li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效</li>
</ul>
</li>
</ul>
<h2 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h2><ul>
<li><p>RT（平均响应时间，秒级）</p>
<p>平均响应时间超出阈值且在时间窗口内通过的请求&gt;&#x3D;5，两个条件同时满足后触发降级</p>
<p>窗口期过后关闭断路器</p>
<p>RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效）</p>
</li>
<li><p>异常比例（秒级）</p>
<p>QPS &gt;&#x3D; 5且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</p>
</li>
<li><p>异常数（分钟级）</p>
<p>异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</p>
</li>
</ul>
<h2 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h2><p>@SentinelResource(value &#x3D; “testHotKey”, blockHandler  &#x3D; “dealHandler_testHotKey”)</p>
<p>方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理</p>
<p>@SentinelResource主管配置出错，运行出错该走异常走异常</p>
]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2023/06/09/ELK/</url>
    <content><![CDATA[<h1 id="Elasticsearch解压安装"><a href="#Elasticsearch解压安装" class="headerlink" title="Elasticsearch解压安装"></a>Elasticsearch解压安装</h1>]]></content>
      <tags>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix</title>
    <url>/2022/12/11/Zabbix/</url>
    <content><![CDATA[<h1 id="解决Server端乱码问题"><a href="#解决Server端乱码问题" class="headerlink" title="解决Server端乱码问题"></a>解决Server端乱码问题</h1><p>zabbix默认监测了服务端本身，但编码有问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装字体</span></span><br><span class="line">yum -y install wqy-microhei-fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制字体</span></span><br><span class="line">\<span class="built_in">cp</span> /usr/share/fonts/wqy-microhei/wqy-microhei.ttc /usr/share/fonts/dejavu/DejaVuSans.ttf</span><br></pre></td></tr></table></figure>

<h1 id="部署Zabbix客户端"><a href="#部署Zabbix客户端" class="headerlink" title="部署Zabbix客户端"></a>部署Zabbix客户端</h1><blockquote>
<p><strong>zabbix-agent2采用golang语言开发，默认10050端口，也就是zabbix客户端的端口</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置时间正确</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate -u ntp.aliyun.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区的统一配置</span></span><br><span class="line"><span class="built_in">mv</span> /etc/localtime&#123;,.bak&#125;</span><br><span class="line"><span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>

<p><strong>zabbix-agent2部署流程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取zabbix下载源</span></span><br><span class="line">rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</span><br><span class="line"><span class="comment"># 更换zabbix.repo源，为阿里的</span></span><br><span class="line">sed -i <span class="string">&#x27;s#http://repo.zabbix.com#https://mirrors.aliyun.com/zabbix#&#x27;</span> /etc/yum.repos.d/zabbix.repo</span><br><span class="line"></span><br><span class="line">yum install zabbix-agent2 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">/etc/zabbix/zabbix_agent2.conf</span><br><span class="line"><span class="comment"># 启动命令</span></span><br><span class="line"><span class="built_in">ls</span> -l /usr/sbin/zabbix_agent2</span><br><span class="line"><span class="comment"># 启动客户端，开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now zabbix-agent2</span><br></pre></td></tr></table></figure>

<p><strong>修改配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_agent2.conf</span><br><span class="line"></span><br><span class="line">Server=1.13.248.197</span><br><span class="line">ServerActive=1.13.248.197</span><br><span class="line">Hostname=机器名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line">grep -Ev <span class="string">&#x27;^#|^$&#x27;</span> /etc/zabbix/zabbix_agent2.conf</span><br></pre></td></tr></table></figure>

<p><strong>重启zabbix</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart zabbix-agent2</span><br></pre></td></tr></table></figure>

<p><strong>验证zabbix-agent2的连通性</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在服务器上通过命令，主动获取数据</span></span><br><span class="line">yum install zabbix-get -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令监测服务端是否连接上客户端</span></span><br><span class="line">zabbix_get -s <span class="string">&#x27;1.13.248.197&#x27;</span> -p 10050 -k <span class="string">&#x27;agent.ping&#x27;</span></span><br><span class="line">zabbix_get -s <span class="string">&#x27;1.13.248.197&#x27;</span> -p 10050 -k <span class="string">&#x27;system.hostname&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="监控Nginx"><a href="#监控Nginx" class="headerlink" title="监控Nginx"></a>监控Nginx</h1><p><strong>确定监控内容：</strong>nginx内置了一个status状态的功能，通过配置可以看到nginx的运行情况，status显示的内容包括当前连接数，处于活动状态的连接数，已经处理的请求数等等。</p>
<p>在nginx的配置文件中，添加status配置，在虚拟主机 server {} 中加入上面配置，也可以单独定义一个专门用于监控的虚拟主机。</p>
<p>deny all , 拒绝除 allow 中的主机之外所有主机访问此URL ，实现过程中如果遇到403 ，有可能是你把自己测试的机器拒绝了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /nginx_status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;		 //关闭日志</span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  allow 192.168.10.5;   //zabbix服务器的IP地址，一般是内网地址</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<p><strong>在zabbix server上测试访问：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://1.13.248.197/status</span><br></pre></td></tr></table></figure>

<img src="/2022/12/11/Zabbix/image-20221228210959320.png" class="" title="image-20221228210959320">

<p>nginx Status 详细说明：</p>
<ul>
<li>Active connections：当前处于活动状态的客户端连接数，包括连接等待空闲连接数。</li>
<li>accepts：统计总值，Nginx自启动后已经接受的客户端请求的总数。</li>
<li>handled：统计总值，Nginx自启动后已经处理完成的客户端请求的总数，一般情况下它和accept值相同，如果不同说明nginx性能出现瓶颈</li>
<li>requests：统计总值，Nginx自启动后客户端发来的总的请求数。</li>
<li>reading：当前状态，正在读取客户端请求报文首部的连接的连接数。</li>
<li>writing：当前状态，正在向客户端发送响应报文过程中的连接数。</li>
<li>waiting：当前状态，正在等待客户端发出请求的空闲连接数，开启 keep-alive的情况下,这个值等于 active –(reading+writing)。</li>
</ul>
<p>在访问效率很高，请求很快被处理完毕的情况下，Waiting 数比较多是正常的。如果 reading + writing 数较多，则说明并发访问量很大，正在处理过程中。</p>
<p><strong>监控脚本编写</strong></p>
<p>编写脚本，放于&#x2F;usr&#x2F;local&#x2F;zabbix&#x2F;scripts目录下</p>
<p>通过脚本获取status页面信息的关键值，zabbix server通过这些关键值才能生成数据图像，获取status的关键值脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/zabbix/scripts</span><br><span class="line">vim /usr/local/zabbix/scripts/nginx_status.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># Description：zabbix监控nginx状态</span></span><br><span class="line"><span class="comment"># Note：此脚本需要配置在被监控端</span></span><br><span class="line">HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">PORT=<span class="string">&quot;80&quot;</span></span><br><span class="line"><span class="comment"># 检测nginx进程是否存在</span></span><br><span class="line"><span class="keyword">function</span> ping &#123;</span><br><span class="line">    /sbin/pidof nginx | <span class="built_in">wc</span> -l</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 检测nginx性能</span></span><br><span class="line"><span class="keyword">function</span> active &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| grep <span class="string">&#x27;Active&#x27;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> reading &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| grep <span class="string">&#x27;Reading&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> writing &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| grep <span class="string">&#x27;Writing&#x27;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> waiting &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| grep <span class="string">&#x27;Waiting&#x27;</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> accepts &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| awk NR==3 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> handled &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| awk NR==3 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> requests &#123;</span><br><span class="line">    /usr/bin/curl <span class="string">&quot;http://<span class="variable">$HOST</span>:<span class="variable">$PORT</span>/status/&quot;</span> 2&gt;/dev/null| awk NR==3 | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 执行function</span></span><br><span class="line"><span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p><strong>本地测试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh /usr/local/zabbix/scripts/ngx_status.sh active</span><br><span class="line">sh /usr/local/zabbix/scripts/ngx_status.sh accepts</span><br></pre></td></tr></table></figure>

<p><strong>赋予脚本执行权限：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/zabbix/scripts/ngx_status.sh</span><br></pre></td></tr></table></figure>

<p><strong>修改zabbix_agent2.conf</strong></p>
<p>使用脚本监控需要将zabbix-agentd.conf文件中的<code>UnsafeUserParameters=1</code> 开启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_agent2.conf</span><br><span class="line"></span><br><span class="line">UnsafeUserParameters=1</span><br></pre></td></tr></table></figure>

<p><strong>定义监控脚本Key</strong></p>
<p>添加zabbix配置文件，放于&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;目录下（agent的配置文件&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf中定义了其他key的包含目录）创建配置文件nginx_status.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_agent2.d/nginx_status.conf</span><br><span class="line"></span><br><span class="line">UserParameter=nginx.status[*],/usr/local/zabbix/scripts/nginx_status.sh <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p><strong>配置好后重启zabbix-agent2</strong></p>
<p><strong>Zabbix服务端使用zabbix_get 测试获取数据</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zabbix_get -s 1.13.248.197 -p 10050 -k nginx.status[ping]</span><br><span class="line">zabbix_get -s 1.13.248.197 -p 10050 -k nginx.status[active]</span><br><span class="line">zabbix_get -s 1.13.248.197 -p 10050 -k nginx.status[accepts]</span><br></pre></td></tr></table></figure>

<p><strong>出现Permission denied问题：</strong></p>
<p>将<code>nginx_status.sh</code>脚本所属用户改为zabbix</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line"><span class="built_in">chown</span> zabbix:zabbix -R zabbix</span><br></pre></td></tr></table></figure>

<p><strong>Web界面配置</strong></p>
<p>创建模板，添加监控项</p>
<img src="/2022/12/11/Zabbix/image-20221229141142940.png" class="" title="image-20221229141142940">

<p>创建图像，关联模板</p>
<img src="/2022/12/11/Zabbix/image-20221229141322844.png" class="" title="image-20221229141322844">
]]></content>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins部署</title>
    <url>/2022/09/06/jenkins%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170427682.png"></p>
<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170459433.png"></p>
<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170537961.png"></p>
<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170618820.png"></p>
<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170654508.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;开始准备打包...&quot;</span><br><span class="line">source /etc/profile</span><br><span class="line">mvn install -s /home/root/apache-maven-3.8.6/conf/settings-mocha-portal.xml</span><br><span class="line">echo &quot;开始准备上传文件...&quot;</span><br><span class="line">echo &quot;$&#123;WORKSPACE&#125;&quot;</span><br><span class="line">cd $&#123;WORKSPACE&#125;/target/</span><br><span class="line">echo &quot;准备上传应用服务器...&quot;</span><br><span class="line">expect &lt;&lt; EOF</span><br><span class="line">set timeout 30</span><br><span class="line">spawn scp -P 22 mc-portal.jar root@172.27.17.59:/home/root/transport</span><br><span class="line">expect &#123;</span><br><span class="line">        &quot;*assword:&quot; &#123; send &quot;Szrd!234\r&quot;; &#125;</span><br><span class="line">        &quot;*yes/no*&quot; &#123; send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line">echo &quot;上传完成...&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/jenkins%E9%83%A8%E7%BD%B2%5Cimage-20220906170722188.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time=$(date &quot;+%Y-%m-%d_%H:%M:%S&quot;)</span><br><span class="line">echo $&#123;time&#125;</span><br><span class="line">cp  /home/root/mc-portal/mc-portal.jar /home/root/mc-portal/backup/mc-portal.jar.$&#123;time&#125;</span><br><span class="line">rm -rf /home/root/mc-portal/mc-portal.jar</span><br><span class="line">mv /home/root/transport/mc-portal.jar  /home/root/mc-portal/mc-portal.jar</span><br><span class="line">cd /home/root/mc-portal/</span><br><span class="line">sh mc-portal.sh restart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash mc-portal.sh</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>将 Bean 放入 Spring 容器中的五种方式！</title>
    <url>/2022/09/09/%E5%B0%86%20Bean%E6%94%BE%E5%85%A5Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="Configuration-Bean"><a href="#Configuration-Bean" class="headerlink" title="@Configuration + @Bean"></a>@Configuration + @Bean</h4><blockquote>
<p>@Configuration用来声明一个配置类，然后使用 @Bean 注解，用于声明一个bean，将其加入到Spring容器中。</p>
</blockquote>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Componet-ComponentScan"><a href="#Componet-ComponentScan" class="headerlink" title="@Componet + @ComponentScan"></a>@Componet + @ComponentScan</h4><blockquote>
<p>这种方式也是我们用的比较多的方式，@Componet中文译为组件，放在类名上面，然后@ComponentScan放置在我们的配置类上，然后可以指定一个路径，进行扫描带有@Componet注解的bean，然后加至容器中。</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.springboot.initbean.*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<p>&#x3D;&#x3D;Person{name&#x3D;’null’}&#x3D;&#x3D;</p>
<p>表示成功将Person放置在了IOC容器中。</p>
<h4 id="Import注解导入"><a href="#Import注解导入" class="headerlink" title="@Import注解导入"></a>@Import注解导入</h4><blockquote>
<p>前两种方式，大家用的可能比较多，也是平时开发中必须要知道的，@Import注解用的可能不是特别多了，但是也是非常重要的，在进行Spring扩展时经常会用到，它经常搭配自定义注解进行使用，然后往容器中导入一个配置文件。</p>
</blockquote>
<p>关于@Import注解，它有四种使用方式。这是@Import注解的源码，表示只能放置在类上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于导入一个class文件</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Import直接导入类"><a href="#Import直接导入类" class="headerlink" title="@Import直接导入类"></a>@Import直接导入类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接使用<span class="doctag">@Import</span>导入person类，然后尝试从applicationContext中取，成功拿到</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Import(Person.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码直接使用@Import导入了一个类，然后自动的就被放置在IOC容器中了。</p>
<p>注意：我们的Person类上 就不需要任何的注解了，直接导入即可。</p>
<h5 id="Import-ImportSelector"><a href="#Import-ImportSelector" class="headerlink" title="@Import + ImportSelector"></a>@Import + ImportSelector</h5><blockquote>
<p>实现一个ImportSelector的接口，然后实现其中的方法，进行导入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.springboot.pojo.Person&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义了一个 MyImportSelector 实现了 ImportSelector 接口，重写selectImports 方法，然后将我们要导入的类的全限定名写在里面即可，实现起来也是非常简单。</p>
<h5 id="Import-ImportBeanDefinitionRegistrar"><a href="#Import-ImportBeanDefinitionRegistrar" class="headerlink" title="@Import + ImportBeanDefinitionRegistrar"></a>@Import + ImportBeanDefinitionRegistrar</h5><blockquote>
<p>这种方式也需要我们实现 ImportBeanDefinitionRegistrar 接口中的方法，具体代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建一个beanDefinition, 关于beanDefinition我后续会介绍，可以简单理解为bean的定义.</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();</span><br><span class="line">        <span class="comment">// 将beanDefinition注册到Ioc容器中.</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;person&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现其实和Import的第二种方式差不多，都需要去实现接口，然后进行导入。接触到了一个新的概念，BeanDefinition，可以简单理解为bean的定义(bean的元数据)，也是需要放在IOC容器中进行管理的，先有bean的元数据，applicationContext再根据bean的元数据去创建Bean。</p>
<h5 id="Import-DeferredImportSelector"><a href="#Import-DeferredImportSelector" class="headerlink" title="@Import + DeferredImportSelector"></a>@Import + DeferredImportSelector</h5><blockquote>
<p>这种方式也需要我们进行实现接口，其实它和@Import的第二种方式差不多，DeferredImportSelector 它是 ImportSelector 的子接口，所以实现的方法和第二种无异。只是Spring的处理方式不同，它和Spring Boot中的自动导入配置文件 延迟导入有关，非常重要。使用方式如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(MyDeferredImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeferredImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">// 也是直接将Person的全限定名放进去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Person.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于@Import注解的使用方式，大概就以上四种，当然它还可以搭配@Configuration注解使用，用于导入一个配置类。</p>
<h4 id="使用FactoryBean接口"><a href="#使用FactoryBean接口" class="headerlink" title="使用FactoryBean接口"></a>使用FactoryBean接口</h4><blockquote>
<p>FactoryBean接口和BeanFactory千万不要弄混了，从名字其实可以大概的区分开，FactoryBean, 后缀为bean，那么它其实就是一个bean, BeanFactory，顾名思义 bean工厂，它是IOC容器的顶级接口，这俩接口都很重要。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersonFactoryBean <span class="title function_">personFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Person&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  直接new出来Person进行返回.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  指定返回bean的类型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，我使用@Configuration + @Bean的方式将 PersonFactoryBean 加入到容器中，注意，我没有向容器中注入 Person, 而是直接注入的 PersonFactoryBean 然后从容器中拿Person这个类型的bean,成功运行。</p>
<h4 id="使用-BeanDefinitionRegistryPostProcessor"><a href="#使用-BeanDefinitionRegistryPostProcessor" class="headerlink" title="使用 BeanDefinitionRegistryPostProcessor"></a>使用 BeanDefinitionRegistryPostProcessor</h4><blockquote>
<p>其实这种方式也是利用到了 BeanDefinitionRegistry，在Spring容器启动的时候会执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法，大概意思就是等beanDefinition加载完毕之后，对beanDefinition进行后置处理，可以在此进行调整IOC容器中的beanDefinition，从而干扰到后面进行初始化bean。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        <span class="type">MyBeanDefinitionRegistryPostProcessor</span> <span class="variable">beanDefinitionRegistryPostProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanDefinitionRegistryPostProcessor</span>();</span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;person&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们手动向beanDefinitionRegistry中注册了person的BeanDefinition。最终成功将person加入到applicationContext中，上述的几种方式的具体原理，我后面会进行介绍。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>(1)	http是超文本传输协议，信息是明文传输，https协议要比http协议安全，https是具有安全性的ssl加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</p>
<p>(2)	http协议的默认端口为80，https的默认端口为443。</p>
<p>(3)	http的连接很简单，是无状态的；https握手阶段比较费时，会使页面加载时间延长50%，增加耗电。</p>
<p>(4)	https缓存不如http高效，会增加数据开销</p>
<p>(5)	https协议需要ca证书，不能在同一个IP上绑定多个域名，IPV4资源支持不了这种消耗。</p>
<h4 id="HTTPS协议的工作原理"><a href="#HTTPS协议的工作原理" class="headerlink" title="HTTPS协议的工作原理"></a>HTTPS协议的工作原理</h4><p>客户端在使用https方式与Web服务器通信时有一下几个步骤：</p>
<p>(1)	客户端使用https url访问服务器，则要求Web服务器建立ssl链接</p>
<p>(2)	Web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端</p>
<p>(3)	客户端和Web服务器端开始协商SSL链接的安全等级，也就是加密等级</p>
<p>(4)	客户端浏览器通过双方协商一直的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站</p>
<p>(5)	Web服务器通过自己的私钥解密出会话密钥</p>
<p>(6)	Web服务器通过会话密钥加密与客户端之间的通信</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>第一次握手：建立连接时，客户端发送SYN包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）；</p>
<p>第二次握手：服务器收到SYN包并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYNC+ACK包，向服务器发送确认包ACK（ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><h4 id="TCP-x2F-IP如何保证数据包传输的有序可靠"><a href="#TCP-x2F-IP如何保证数据包传输的有序可靠" class="headerlink" title="TCP&#x2F;IP如何保证数据包传输的有序可靠"></a>TCP&#x2F;IP如何保证数据包传输的有序可靠</h4><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>(1)	TCP是面向链接的，而UDP是面向无连接的</p>
<p>(2)	TCP仅支持单播传输，UDP提供了单播，多播，广播的功能</p>
<p>(3)	TCP的三次握手保证 了连接的可靠性；UDP是无连接的、不可靠的一种数据传输协议，首先不可靠体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收</p>
<p>(4)	UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好</p>
<h4 id="HTTP和RPC协议的区别"><a href="#HTTP和RPC协议的区别" class="headerlink" title="HTTP和RPC协议的区别"></a>HTTP和RPC协议的区别</h4><ul>
<li>http是应用层的超文本传输协议，是万维网数据传输通信的一个基础， 主要服务在于网页端和服务端之间一个数据传输上；rpc是一个远程过程调用协议，是定位在实现不同计算机应用之间的一个数据通信，&#x3D;&#x3D;屏蔽了通信的底层复杂度&#x3D;&#x3D;，让开发者能够像调用本地服务一样，去完成远程服务的调用。因此，在定位层面是完全不同的。</li>
<li>从实现层面来说，http协议是一个已经实现并且成熟的应用层协议，定义了通信报文的一些格式， &#x3D;&#x3D;比如像RequestBody，RequestHead以及ReponseBody和ReponseHeader，也就是说符合这样一个协议特征的通信协议才是http协议&#x3D;&#x3D;；rpc只是一种通信协议的一个规范，并没有具体的实现，只有按照rpc通信协议规范去实现的通信框架才是协议的真正具体的一个实现，如Dubbo，gRPC等等。因此，可以在实现rpc框架的时候 ，自定义报文通信的协议规范和自定义序列化方式，或者自定义网络通信协议的类型等等。所有，&#x3D;&#x3D;http协议是一个成熟的应用层协议，rpc只是定义了不同服务之间数据通信的一个规范&#x3D;&#x3D;。最后从应用层面来说，http协议和实现了rpc协议的框架都能够去实现跨网络节点之间的一些服务通信，并且&#x3D;&#x3D;底层都是用的TCP&#x2F;IP协议作为通信基础&#x3D;&#x3D;。但是由于rpc只是一种标准协议，只需要符合rpc协议的框架，都属于rpc框架，因此，rpc网络通信协议层，也可以使用http协议去实现，如gRPC，OpenFeign底层都采用了http协议，作为通信的基础。</li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote>
<p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
</blockquote>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingle</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，不允许外部new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有静态属性直接创建对象，外部无法访问，且唯一存在</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingle</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有静态方法，获取唯一对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingle</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，不允许外部new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有静态属性，但不直接创建对象，延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MySingle single;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有静态方法，使用的时候再创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>)&#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">MySingle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="懒汉式-加锁-保证线程安全"><a href="#懒汉式-加锁-保证线程安全" class="headerlink" title="懒汉式 加锁 保证线程安全"></a>懒汉式 加锁 保证线程安全</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式 加锁 保证线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingle</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，不允许外部new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有静态属性，但不直接创建对象，延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MySingle single;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有静态方法，使用的时候再创建，同时添加synchronized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> MySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>)&#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">MySingle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="懒汉式-双重检测"><a href="#懒汉式-双重检测" class="headerlink" title="懒汉式 双重检测"></a>懒汉式 双重检测</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式 双重检测</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingle</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，不允许外部new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//volatile修饰，防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> MySingle single;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一重校验，检查实例是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span>(MySingle.class)&#123;</span><br><span class="line">                <span class="comment">//第二重校验，检查实例是否存在，如果不存在，则创建</span></span><br><span class="line">                <span class="keyword">if</span>(single == <span class="literal">null</span>)&#123;</span><br><span class="line">                    single = <span class="keyword">new</span> <span class="title class_">MySingle</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingle</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，不允许外部new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有静态内部类，包含单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySingle</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有静态方法，可以直接获取内部类唯一对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerSingleton.single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MySingle</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个枚举，代表了Singleton的一个实例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do any thing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><blockquote>
<p>工厂方法模式的一种特例。</p>
</blockquote>
<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><blockquote>
<p>工厂方法模式比起简单工厂模式更加符合开闭原则。</p>
</blockquote>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><blockquote>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。</p>
</blockquote>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote>
<p>建造者模式是让建造者类来负责对象的创建工作</p>
</blockquote>
<h5 id="构建者模式——生成器模式"><a href="#构建者模式——生成器模式" class="headerlink" title="构建者模式——生成器模式"></a>构建者模式——生成器模式</h5><blockquote>
<p>与工厂模式的区别：</p>
</blockquote>
<ul>
<li>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</li>
<li>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>
</blockquote>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ul>
<li><p>浅拷贝：浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。</p>
</li>
<li><p>深拷贝：深拷贝不仅仅会复制索引，还会复制数据本身。</p>
</li>
</ul>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote>
<p>它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>业务系统的非功能性需求开发：</li>
</ul>
<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</p>
<ul>
<li>代理模式在 RPC、缓存中的应用：</li>
</ul>
<p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。、</p>
<ul>
<li>代理模式在缓存中的应用：</li>
</ul>
<p>在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote>
<ul>
<li><p>桥梁模式——Bridge Design Pattern</p>
</li>
<li><p>将抽象和实现解耦，让它们可以独立变化。</p>
</li>
<li><p>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p>
</li>
<li><p>通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>
</li>
</ul>
</blockquote>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><blockquote>
<ul>
<li><p>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p>
</li>
<li><p>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p>
</li>
</ul>
</blockquote>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<ul>
<li>这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</li>
<li>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</li>
</ul>
</blockquote>
<p>实现方式：</p>
<ul>
<li>类适配器——使用继承关系来实现</li>
<li>对象适配器——使用组合关系来实现</li>
</ul>
<p>总结：</p>
<ul>
<li><p>封装有缺陷的接口设计</p>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
</li>
<li><p>统一多个类的接口设计</p>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p>
</li>
<li><p>替换依赖的外部系统</p>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>
</li>
<li><p>兼容老版本接口</p>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p>
</li>
<li><p>适配不同格式的数据它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。</p>
</li>
</ul>
<h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><blockquote>
<ul>
<li>外观模式——门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li>
<li>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。</li>
<li>门面模式让子系统更加易用</li>
<li>从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</li>
</ul>
</blockquote>
<p>应用场景：</p>
<ul>
<li><p>解决易用性问题</p>
<ul>
<li>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。</li>
<li>Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</li>
</ul>
</li>
<li><p>解决性能问题</p>
<ul>
<li>我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。</li>
</ul>
</li>
<li><p>解决分布式事务问题</p>
<ul>
<li>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。</li>
<li>我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</li>
</ul>
</li>
</ul>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><blockquote>
<ul>
<li>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。</li>
<li>组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</li>
</ul>
</blockquote>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><blockquote>
<ul>
<li>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</li>
<li>当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。</li>
</ul>
</blockquote>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><blockquote>
<ul>
<li>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</li>
<li>被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。</li>
<li>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</li>
<li>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</li>
<li>基于消息队列（Message Queue，比如 ActiveMQ）来实现。</li>
</ul>
</blockquote>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><blockquote>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<p>作用：</p>
<ul>
<li>复用</li>
<li>扩展</li>
</ul>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><blockquote>
<ul>
<li>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。</li>
<li>策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</li>
<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</li>
<li>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</li>
</ul>
</blockquote>
<h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><blockquote>
<ul>
<li>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</li>
<li>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</li>
<li>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。</li>
</ul>
</blockquote>
<h4 id="状态模式——有限状态机"><a href="#状态模式——有限状态机" class="headerlink" title="状态模式——有限状态机"></a>状态模式——有限状态机</h4><blockquote>
<ul>
<li>英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。</li>
<li>状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。</li>
<li>事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。</li>
<li>实现方式<ul>
<li>分支逻辑法</li>
<li>查表法</li>
<li>状态模式</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><blockquote>
<ul>
<li>用来遍历集合对象——大部分编程语言都提供了多种遍历集合的方式，比如 for 循环、foreach 循环、迭代器等。</li>
<li>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</li>
</ul>
</blockquote>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><blockquote>
<ul>
<li>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</li>
<li>访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。</li>
<li>它们继承相同的父类（ResourceFile）或者实现相同的接口。</li>
</ul>
</blockquote>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><blockquote>
<ul>
<li>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</li>
<li>两部分<ul>
<li>存储副本以便后期恢复</li>
<li>要在不违背封装原则的前提下，进行对象的备份和恢复</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote>
<ul>
<li>将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</li>
<li>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</li>
</ul>
</blockquote>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><blockquote>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
</blockquote>
<h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><blockquote>
<p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
</blockquote>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Exception总结</title>
    <url>/2023/02/13/Exception%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>解决java.util.LinkedHashMap cannot be cast to 实体类…的问题</strong></p>
<blockquote>
<p>使用openfeign进行远程调用，由于有个接口返回的是R&lt;List&lt;·Object&gt;&gt;类型的数据，在调用方使用List&lt;·Object&gt;去接收数据时，出现java.util.LinkedHashMap cannot be cast to xxx数据转换异常错误。可知远程调用会将待转换的数据转换成LinkedHashMap，而将其转换成想要的数据类型，肯定行不通。</p>
</blockquote>
<p>解决办法一：</p>
<blockquote>
<p>使用alibaba提供的fastjson工具中的TypeReference，进行转换。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2022/07/29/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux下编译安装"><a href="#Linux下编译安装" class="headerlink" title="Linux下编译安装"></a>Linux下编译安装</h1><blockquote>
<p>下载地址：<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">https://mirrors.edge.kernel.org/pub/software/scm/git/</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上传tar.gz；解压</span></span><br><span class="line"><span class="comment"># 安装编译环境</span></span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br><span class="line"><span class="comment"># 安装该编译环境的时候，yum自动安装了git，需要先卸载这个旧版的git</span></span><br><span class="line">yum -y remove git</span><br><span class="line"><span class="comment"># 进入到刚刚解压的git文件夹中，prefix参数为安装位置</span></span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置环境变量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下</span></span><br><span class="line"><span class="built_in">export</span> GIT_HOME=/usr/local/git</span><br><span class="line"><span class="comment"># 这边已经先配置了JDK，所以在PATH后追加</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$GIT_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新配置文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看git版本</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>



<ol>
<li><p>用<code>git commit -a</code>提交了一次变化，而又不确定提交了哪些内容，可以使用如下命令显示当前HEAD上的最近一次的提交（commit）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git show</span><br><span class="line">$ git <span class="built_in">log</span> -n1 -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果提交信息（commit message）写错了且这次提交（commit）还没有推（push），可以通过下面的方法来修改提交信息（commit message）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend --only</span><br></pre></td></tr></table></figure>

<p>这会打开你的默认编辑器，在这里你可以编辑信息，另一方面，你也可以用一条命令一次完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   $ git commit --amend --only -m <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">​		如果已经推（push）了这次提交（commit），可以修改这次提交（commit）然后强推（force push），但是不推荐这么做。</span><br><span class="line"></span><br><span class="line">3. 提交（commit）里的用户名和邮箱不对</span><br><span class="line"></span><br><span class="line">   如果这只是单个提交（commit），修改它：</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   $ git commit --amend --autor <span class="string">&quot;New AuthorName&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果需要修改所有历史，参考<code>git filter-branch</code>的指南页。</p>
</li>
<li><p>我想从一个提交（commit）里移除一个文件</p>
<p>通过下面的方法，从一个提交（commit）里移除一个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout HEAD^ myfile</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>当往上面提交了一个不必要的文件，你需要强推（force push）去更新这个远程补丁。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
